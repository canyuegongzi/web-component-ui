(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{420:function(a,e,s){a.exports=s.p+"assets/img/cache.d397f083.png"},593:function(a,e,s){"use strict";s.r(e);var t=s(45),v=Object(t.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"缓存机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存机制"}},[a._v("#")]),a._v(" 缓存机制")]),a._v(" "),t("p",[a._v("缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。")]),a._v(" "),t("p",[a._v("浏览器缓存，也称Http缓存，分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。")]),a._v(" "),t("p",[a._v("接下来以三个部分来把浏览器的缓存机制说清楚：")]),a._v(" "),t("ul",[t("li",[a._v("强缓存")]),a._v(" "),t("li",[a._v("协商缓存")]),a._v(" "),t("li",[a._v("缓存位置")])]),a._v(" "),t("h2",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),t("p",[a._v("浏览器中的缓存作用分为两种情况，一种是需要发送"),t("code",[a._v("HTTP")]),a._v("请求，一种是不需要发送。")]),a._v(" "),t("p",[a._v("首先是向浏览器缓存发起检查，这个阶段不需要发送"),t("code",[a._v("HTTP")]),a._v("请求。")]),a._v(" "),t("h3",{attrs:{id:"expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),t("p",[a._v("Expires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Expires"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Wed"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v(" Nov "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2019")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("08")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("41")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("00")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n")])])]),t("p",[a._v("表示资源在"),t("code",[a._v("2019年11月22号8点41分")]),a._v("过期，过期了就得向服务端发请求。")]),a._v(" "),t("p",[a._v("这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是"),t("strong",[a._v("服务器的时间和浏览器的时间可能并不一致")]),a._v("，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。")]),a._v(" "),t("h3",{attrs:{id:"cache-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),t("p",[a._v("在HTTP1.1 新增了 "),t("code",[a._v("Cache-Control")]),a._v(" 字段来完成 "),t("code",[a._v("expires")]),a._v(" 的任务。")]),a._v(" "),t("p",[a._v("它和"),t("code",[a._v("Expires")]),a._v("本质的不同在于它并没有采用"),t("strong",[a._v("具体的过期时间点")]),a._v("这个方式，而是采用过期时长来控制缓存，对应的字段是"),t("code",[a._v("max-age")]),a._v("。比如这个例子:")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Cache"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Control"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" max"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("age"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3600")]),a._v("\n")])])]),t("p",[a._v("代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。")]),a._v(" "),t("p",[a._v("Cache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令：")]),a._v(" "),t("p",[t("img",{attrs:{src:s(420),alt:""}})]),a._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[t("code",[a._v("Expires")]),a._v(" 是http1.0的产物，"),t("code",[a._v("Cache-Control")]),a._v(" 是http1.1的产物。")]),a._v(" "),t("p",[t("code",[a._v("Cache-Control")]),a._v(" 相对于 "),t("code",[a._v("Expires")]),a._v(" 更加准确，它的优先级也更高。")]),a._v(" "),t("p",[a._v("两者同时存在的话，"),t("strong",[a._v("Cache-Control优先级高于Expires")]),a._v("；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。")]),a._v(" "),t("ul",[t("li",[a._v("缓存生效：返回 200 OK (from memory cache) (from disk cache)")]),a._v(" "),t("li",[a._v("缓存失效：进入协商缓存")])]),a._v(" "),t("h2",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),t("p",[t("strong",[a._v("协商缓存依赖于服务端与浏览器之间的通信。")])]),a._v(" "),t("p",[a._v("浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：")]),a._v(" "),t("ul",[t("li",[a._v("协商缓存生效，返回304和Not Modified")]),a._v(" "),t("li",[a._v("协商缓存失效，返回200和请求结果")])]),a._v(" "),t("p",[a._v("协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。")]),a._v(" "),t("h3",{attrs:{id:"last-modified"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[a._v("#")]),a._v(" Last-Modified")]),a._v(" "),t("p",[a._v("即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头(Response Headers)中加上这个字段：")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Last"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Modified"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Fri"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v(" Jul "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2016")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("01")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("47")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("00")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n")])])]),t("p",[a._v("浏览器接收到后，如果再次请求，会在请求头中携带"),t("code",[a._v("If-Modified-Since")]),a._v("的字段，它的值正是上一次 response 返回给它的 "),t("code",[a._v("last-modified")]),a._v(" 值：")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("If"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Modified"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Since"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Fri"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("27")]),a._v(" Oct "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2017")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("06")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("35")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("57")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n")])])]),t("p",[a._v("服务器拿到请求头中的"),t("code",[a._v("If-Modified-Since")]),a._v("的字段后，会跟服务器中该资源的最后修改时间进行对比:")]),a._v(" "),t("ul",[t("li",[a._v("如果发生了变化，就会返回新的资源和200，跟常规的HTTP请求响应的流程一样。并在 Response Headers 中添加新的 "),t("code",[a._v("Last-Modified")]),a._v(" 值；")]),a._v(" "),t("li",[a._v("否则返回304，告诉浏览器直接从缓存读取。Response Headers 不会再添加 "),t("code",[a._v("Last-Modified")]),a._v(" 字段。")])]),a._v(" "),t("h3",{attrs:{id:"etag"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[a._v("#")]),a._v(" ETag")]),a._v(" "),t("p",[t("strong",[a._v("Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。")])]),a._v(" "),t("p",[a._v("浏览器接收到"),t("code",[a._v("ETag")]),a._v("的值，会在下次请求时，将这个值作为"),t("code",[a._v("If-None-Match")]),a._v("这个字段的内容，并放到请求头中，然后发给服务器。")]),a._v(" "),t("p",[a._v("服务器接收到"),t("code",[a._v("If-None-Match")]),a._v("后，会跟服务器上该资源的"),t("code",[a._v("ETag")]),a._v("进行比对:")]),a._v(" "),t("ul",[t("li",[a._v("如果两者不一样，说明要更新了。返回新的资源和200，跟常规的HTTP请求响应的流程一样。")]),a._v(" "),t("li",[a._v("否则返回304，告诉浏览器直接用缓存。")])]),a._v(" "),t("h3",{attrs:{id:"两者对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两者对比"}},[a._v("#")]),a._v(" 两者对比")]),a._v(" "),t("ol",[t("li",[a._v("在精准度上，"),t("code",[a._v("ETag")]),a._v("优于"),t("code",[a._v("Last-Modified")]),a._v("。")])]),a._v(" "),t("p",[a._v("由于"),t("code",[a._v("ETag")]),a._v("是按照内容给资源上标识，因此能准确感知资源的变化。而"),t("code",[a._v("Last-Modified")]),a._v("就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:")]),a._v(" "),t("ul",[t("li",[a._v("编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。")]),a._v(" "),t("li",[t("code",[a._v("Last-Modified")]),a._v("能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的"),t("code",[a._v("Last-Modified")]),a._v("并没有体现出修改了。")])]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[a._v("在性能上，"),t("code",[a._v("Last-Modified")]),a._v("优于"),t("code",[a._v("ETag")]),a._v("，也很简单理解，"),t("code",[a._v("Last-Modified")]),a._v("仅仅只是记录一个时间点，而"),t("code",[a._v("Etag")]),a._v("需要根据文件的具体内容生成哈希值。")])]),a._v(" "),t("li",[t("p",[a._v("在优先级上，服务器校验优先考虑"),t("code",[a._v("Etag")])])])]),a._v(" "),t("h2",{attrs:{id:"缓存机制-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存机制-2"}},[a._v("#")]),a._v(" 缓存机制")]),a._v(" "),t("p",[a._v("强制缓存优先于协商缓存进行，若强制缓存"),t("code",[a._v("(Expires和Cache-Control)")]),a._v("生效则直接使用缓存，若不生效则进行协商缓存"),t("code",[a._v("(Last-Modified / If-Modified-Since和Etag / If-None-Match)")]),a._v("。")]),a._v(" "),t("p",[a._v("协商缓存由服务器决定是否使用缓存，")]),a._v(" "),t("p",[a._v("若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；")]),a._v(" "),t("p",[a._v("生效则返回304，继续使用缓存。")]),a._v(" "),t("h2",{attrs:{id:"缓存位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[a._v("#")]),a._v(" 缓存位置")]),a._v(" "),t("p",[a._v("前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？")]),a._v(" "),t("p",[a._v("浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：")]),a._v(" "),t("ul",[t("li",[a._v("Service Worker")]),a._v(" "),t("li",[a._v("Memory Cache（内存缓存）")]),a._v(" "),t("li",[a._v("Disk Cache（硬盘缓存）")]),a._v(" "),t("li",[a._v("Push Cache（推送缓存）")])]),a._v(" "),t("h3",{attrs:{id:"service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[a._v("#")]),a._v(" Service Worker")]),a._v(" "),t("p",[a._v("和Web Worker类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的")]),a._v(" "),t("h3",{attrs:{id:"memory-cache-和-disk-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache-和-disk-cache"}},[a._v("#")]),a._v(" Memory Cache 和 Disk Cache")]),a._v(" "),t("p",[a._v("Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。")]),a._v(" "),t("p",[a._v("Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。")]),a._v(" "),t("p",[a._v("好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：")]),a._v(" "),t("ul",[t("li",[a._v("比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存")]),a._v(" "),t("li",[a._v("内存使用率比较高的时候，文件优先进入磁盘")])]),a._v(" "),t("h3",{attrs:{id:"push-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),t("p",[a._v("即推送缓存，这是浏览器缓存的最后一道防线。是HTTP/2的内容，目前应用较少")]),a._v(" "),t("p",[a._v("Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，应用范围有限不代表不重要——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键特性有所了解：")]),a._v(" "),t("ul",[t("li",[a._v("Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。")]),a._v(" "),t("li",[a._v("Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。")]),a._v(" "),t("li",[a._v("不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。")])]),a._v(" "),t("h2",{attrs:{id:"缓存策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存策略"}},[a._v("#")]),a._v(" 缓存策略")]),a._v(" "),t("h3",{attrs:{id:"频繁变动的资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#频繁变动的资源"}},[a._v("#")]),a._v(" 频繁变动的资源")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Cache"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Control"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" no"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("cache\n")])])]),t("p",[a._v("对于频繁变动的资源，首先需要使用 "),t("code",[a._v("Cache-Control: no-cache")]),a._v(" 使浏览器每次都请求服务器，然后配合 "),t("code",[a._v("ETag")]),a._v(" 或者 "),t("code",[a._v("Last-Modified")]),a._v(" 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。")]),a._v(" "),t("h3",{attrs:{id:"不常变化的资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不常变化的资源"}},[a._v("#")]),a._v(" 不常变化的资源")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Cache"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Control"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" max"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("age"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("31536000")]),a._v("\n")])])]),t("p",[a._v("通常在处理这类资源时，给它们的 "),t("code",[a._v("Cache-Control")]),a._v(" 配置一个很大的 "),t("code",[a._v("max-age=31536000")]),a._v(" (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。")]),a._v(" "),t("p",[a._v("在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。")]),a._v(" "),t("h3",{attrs:{id:"用户行为对浏览器缓存的影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用户行为对浏览器缓存的影响"}},[a._v("#")]),a._v(" 用户行为对浏览器缓存的影响")]),a._v(" "),t("p",[a._v("所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：")]),a._v(" "),t("ul",[t("li",[a._v("打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。")]),a._v(" "),t("li",[a._v("普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。")]),a._v(" "),t("li",[a._v("强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 "),t("code",[a._v("Cache-control: no-cache")]),a._v(" (为了兼容，还带了 "),t("code",[a._v("Pragma: no-cache")]),a._v(")，服务器直接返回 200 和最新内容。")])]),a._v(" "),t("h2",{attrs:{id:"总结-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[a._v("对浏览器的缓存机制来做个简要的总结:")]),a._v(" "),t("p",[a._v("首先通过"),t("code",[a._v("Cache-Control")]),a._v("验证强缓存是否可用")]),a._v(" "),t("ul",[t("li",[a._v("向浏览器缓存发起请求，如果强缓存可用，直接使用")]),a._v(" "),t("li",[a._v("否则进入协商缓存，即发送"),t("code",[a._v("HTTP")]),a._v("请求，服务器通过请求头中的"),t("code",[a._v("If-Modified-Since")]),a._v("或者"),t("code",[a._v("If-None-Match")]),a._v("这些条件请求字段检查资源是否更新\n"),t("ul",[t("li",[a._v("若资源更新，返回资源和200状态码")]),a._v(" "),t("li",[a._v("否则，返回304，告诉浏览器直接从缓存获取资源，再从浏览器缓存获取资源")])])])]),a._v(" "),t("br"),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/54cc04190252?_blank",target:"_blank",rel:"noopener noreferrer"}},[a._v("深入理解浏览器的缓存机制"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/fengshi123/blog/issues/7",target:"_blank",rel:"noopener noreferrer"}},[a._v("深入理解HTTP缓存机制及原理"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=v.exports}}]);