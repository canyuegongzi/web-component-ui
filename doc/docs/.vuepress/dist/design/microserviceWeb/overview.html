<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>微前端综述 | Marvin</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/images/photo.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="Live and Study.">
    <meta name="theme-color" content="#0084ff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/images/photo">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.18e459b6.css" as="style"><link rel="preload" href="/assets/js/app.04e7effe.js" as="script"><link rel="preload" href="/assets/js/2.7500209f.js" as="script"><link rel="preload" href="/assets/js/4.31e593be.js" as="script"><link rel="prefetch" href="/assets/js/10.fc55a66c.js"><link rel="prefetch" href="/assets/js/100.da2b8a26.js"><link rel="prefetch" href="/assets/js/101.b6935311.js"><link rel="prefetch" href="/assets/js/102.8a143852.js"><link rel="prefetch" href="/assets/js/103.ac0bff0d.js"><link rel="prefetch" href="/assets/js/104.a53ad8c9.js"><link rel="prefetch" href="/assets/js/105.09a69c32.js"><link rel="prefetch" href="/assets/js/106.ec3222df.js"><link rel="prefetch" href="/assets/js/107.36345c4c.js"><link rel="prefetch" href="/assets/js/108.63c00b35.js"><link rel="prefetch" href="/assets/js/109.267b950b.js"><link rel="prefetch" href="/assets/js/11.878254a1.js"><link rel="prefetch" href="/assets/js/110.67210d85.js"><link rel="prefetch" href="/assets/js/111.1fd0b349.js"><link rel="prefetch" href="/assets/js/112.aa376a08.js"><link rel="prefetch" href="/assets/js/113.f378e496.js"><link rel="prefetch" href="/assets/js/114.47991f9d.js"><link rel="prefetch" href="/assets/js/115.9c5d7278.js"><link rel="prefetch" href="/assets/js/116.6b00856c.js"><link rel="prefetch" href="/assets/js/117.39d23ee6.js"><link rel="prefetch" href="/assets/js/118.ab008fc4.js"><link rel="prefetch" href="/assets/js/119.bb2cd752.js"><link rel="prefetch" href="/assets/js/12.01b414e5.js"><link rel="prefetch" href="/assets/js/120.8d64c315.js"><link rel="prefetch" href="/assets/js/121.9c094ce1.js"><link rel="prefetch" href="/assets/js/122.7eb858c2.js"><link rel="prefetch" href="/assets/js/123.e5034b8e.js"><link rel="prefetch" href="/assets/js/124.1991151b.js"><link rel="prefetch" href="/assets/js/125.e2daec1a.js"><link rel="prefetch" href="/assets/js/126.b5193b9d.js"><link rel="prefetch" href="/assets/js/127.352cedcd.js"><link rel="prefetch" href="/assets/js/128.0ff04116.js"><link rel="prefetch" href="/assets/js/129.1c7ae095.js"><link rel="prefetch" href="/assets/js/13.b3cbd327.js"><link rel="prefetch" href="/assets/js/130.b094968e.js"><link rel="prefetch" href="/assets/js/131.246a3254.js"><link rel="prefetch" href="/assets/js/132.9f70b89c.js"><link rel="prefetch" href="/assets/js/133.135641ff.js"><link rel="prefetch" href="/assets/js/134.0ab679c8.js"><link rel="prefetch" href="/assets/js/135.410a3ea5.js"><link rel="prefetch" href="/assets/js/136.6e84fb22.js"><link rel="prefetch" href="/assets/js/137.eb590c89.js"><link rel="prefetch" href="/assets/js/138.b6c67130.js"><link rel="prefetch" href="/assets/js/139.ee0559f1.js"><link rel="prefetch" href="/assets/js/14.6f67ae27.js"><link rel="prefetch" href="/assets/js/140.9900d1ab.js"><link rel="prefetch" href="/assets/js/141.10e501dd.js"><link rel="prefetch" href="/assets/js/142.7ba60c9b.js"><link rel="prefetch" href="/assets/js/143.10cc2a8b.js"><link rel="prefetch" href="/assets/js/144.4a488e52.js"><link rel="prefetch" href="/assets/js/145.d233fde1.js"><link rel="prefetch" href="/assets/js/146.5d6e19e2.js"><link rel="prefetch" href="/assets/js/147.741dfcd8.js"><link rel="prefetch" href="/assets/js/148.e36a9156.js"><link rel="prefetch" href="/assets/js/149.d777f82c.js"><link rel="prefetch" href="/assets/js/15.b39f9776.js"><link rel="prefetch" href="/assets/js/150.c8a87627.js"><link rel="prefetch" href="/assets/js/151.77b42e3e.js"><link rel="prefetch" href="/assets/js/152.aaefb491.js"><link rel="prefetch" href="/assets/js/153.cd8050cb.js"><link rel="prefetch" href="/assets/js/154.da30271a.js"><link rel="prefetch" href="/assets/js/155.a9a73e30.js"><link rel="prefetch" href="/assets/js/156.67e50f2f.js"><link rel="prefetch" href="/assets/js/157.4238e927.js"><link rel="prefetch" href="/assets/js/158.71819de1.js"><link rel="prefetch" href="/assets/js/159.1a9d1614.js"><link rel="prefetch" href="/assets/js/16.b3fd14b8.js"><link rel="prefetch" href="/assets/js/160.23819dac.js"><link rel="prefetch" href="/assets/js/161.891ee1c4.js"><link rel="prefetch" href="/assets/js/162.14acaaf5.js"><link rel="prefetch" href="/assets/js/163.f69193a8.js"><link rel="prefetch" href="/assets/js/164.03cb90cf.js"><link rel="prefetch" href="/assets/js/165.a68789f2.js"><link rel="prefetch" href="/assets/js/166.5062976f.js"><link rel="prefetch" href="/assets/js/167.5be7084a.js"><link rel="prefetch" href="/assets/js/168.024e56b2.js"><link rel="prefetch" href="/assets/js/169.c8793766.js"><link rel="prefetch" href="/assets/js/17.fbe4d128.js"><link rel="prefetch" href="/assets/js/170.ff241220.js"><link rel="prefetch" href="/assets/js/171.f6f87043.js"><link rel="prefetch" href="/assets/js/172.a8802c14.js"><link rel="prefetch" href="/assets/js/173.8194b3ba.js"><link rel="prefetch" href="/assets/js/174.3407c7a4.js"><link rel="prefetch" href="/assets/js/18.34722ffd.js"><link rel="prefetch" href="/assets/js/19.f2f0dacc.js"><link rel="prefetch" href="/assets/js/20.ee107830.js"><link rel="prefetch" href="/assets/js/21.42b87210.js"><link rel="prefetch" href="/assets/js/22.a3a38f7d.js"><link rel="prefetch" href="/assets/js/23.a7b04e59.js"><link rel="prefetch" href="/assets/js/24.5cf03549.js"><link rel="prefetch" href="/assets/js/25.b43bf114.js"><link rel="prefetch" href="/assets/js/26.118bfb42.js"><link rel="prefetch" href="/assets/js/27.f2d87055.js"><link rel="prefetch" href="/assets/js/28.27ba0e02.js"><link rel="prefetch" href="/assets/js/29.05093ddb.js"><link rel="prefetch" href="/assets/js/3.032262d1.js"><link rel="prefetch" href="/assets/js/30.856f2739.js"><link rel="prefetch" href="/assets/js/31.8e6c9fb3.js"><link rel="prefetch" href="/assets/js/32.b8a2b197.js"><link rel="prefetch" href="/assets/js/33.3993d113.js"><link rel="prefetch" href="/assets/js/34.de836c68.js"><link rel="prefetch" href="/assets/js/35.d1ea9071.js"><link rel="prefetch" href="/assets/js/36.34f4474d.js"><link rel="prefetch" href="/assets/js/37.61999d96.js"><link rel="prefetch" href="/assets/js/38.f7b8cfc7.js"><link rel="prefetch" href="/assets/js/39.6fc071b5.js"><link rel="prefetch" href="/assets/js/40.e79c89ac.js"><link rel="prefetch" href="/assets/js/41.6012ba96.js"><link rel="prefetch" href="/assets/js/42.43bab019.js"><link rel="prefetch" href="/assets/js/43.2cc54523.js"><link rel="prefetch" href="/assets/js/44.382e15f2.js"><link rel="prefetch" href="/assets/js/45.4a7766c7.js"><link rel="prefetch" href="/assets/js/46.d3495bfa.js"><link rel="prefetch" href="/assets/js/47.359f00db.js"><link rel="prefetch" href="/assets/js/48.47ffce1f.js"><link rel="prefetch" href="/assets/js/49.ea135a9e.js"><link rel="prefetch" href="/assets/js/5.c24604c2.js"><link rel="prefetch" href="/assets/js/50.57b32d78.js"><link rel="prefetch" href="/assets/js/51.0d74062d.js"><link rel="prefetch" href="/assets/js/52.8d513397.js"><link rel="prefetch" href="/assets/js/53.ed9327e5.js"><link rel="prefetch" href="/assets/js/54.46981ba5.js"><link rel="prefetch" href="/assets/js/55.7412d3a1.js"><link rel="prefetch" href="/assets/js/56.8e4e6359.js"><link rel="prefetch" href="/assets/js/57.83795c1c.js"><link rel="prefetch" href="/assets/js/58.e1551a92.js"><link rel="prefetch" href="/assets/js/59.8c7659c6.js"><link rel="prefetch" href="/assets/js/6.fd360a9b.js"><link rel="prefetch" href="/assets/js/60.f1aa6400.js"><link rel="prefetch" href="/assets/js/61.feba7e36.js"><link rel="prefetch" href="/assets/js/62.a7abe9d3.js"><link rel="prefetch" href="/assets/js/63.583cf8f5.js"><link rel="prefetch" href="/assets/js/64.b1b7c954.js"><link rel="prefetch" href="/assets/js/65.7382f674.js"><link rel="prefetch" href="/assets/js/66.85fec513.js"><link rel="prefetch" href="/assets/js/67.678a7f9e.js"><link rel="prefetch" href="/assets/js/68.02ee3d1f.js"><link rel="prefetch" href="/assets/js/69.abfe586b.js"><link rel="prefetch" href="/assets/js/7.6bc85ee3.js"><link rel="prefetch" href="/assets/js/70.ee8b1de4.js"><link rel="prefetch" href="/assets/js/71.5c5171ae.js"><link rel="prefetch" href="/assets/js/72.8152f2e5.js"><link rel="prefetch" href="/assets/js/73.4746a9c3.js"><link rel="prefetch" href="/assets/js/74.4b82ab8a.js"><link rel="prefetch" href="/assets/js/75.7381d7a2.js"><link rel="prefetch" href="/assets/js/76.a543d489.js"><link rel="prefetch" href="/assets/js/77.20191838.js"><link rel="prefetch" href="/assets/js/78.40acce53.js"><link rel="prefetch" href="/assets/js/79.c432c2bb.js"><link rel="prefetch" href="/assets/js/8.b698345f.js"><link rel="prefetch" href="/assets/js/80.fb9155a3.js"><link rel="prefetch" href="/assets/js/81.47267ef6.js"><link rel="prefetch" href="/assets/js/82.fee7348a.js"><link rel="prefetch" href="/assets/js/83.2a4cfb3e.js"><link rel="prefetch" href="/assets/js/84.b87d5ff0.js"><link rel="prefetch" href="/assets/js/85.96d50c13.js"><link rel="prefetch" href="/assets/js/86.9d048eef.js"><link rel="prefetch" href="/assets/js/87.27a8acaa.js"><link rel="prefetch" href="/assets/js/88.615206ef.js"><link rel="prefetch" href="/assets/js/89.878f4ade.js"><link rel="prefetch" href="/assets/js/9.00329a71.js"><link rel="prefetch" href="/assets/js/90.35ee76b2.js"><link rel="prefetch" href="/assets/js/91.2487fc4a.js"><link rel="prefetch" href="/assets/js/92.f04bab8e.js"><link rel="prefetch" href="/assets/js/93.a36da124.js"><link rel="prefetch" href="/assets/js/94.a2ce4ded.js"><link rel="prefetch" href="/assets/js/95.2ed2d8fd.js"><link rel="prefetch" href="/assets/js/96.805f0dda.js"><link rel="prefetch" href="/assets/js/97.3d722d32.js"><link rel="prefetch" href="/assets/js/98.90e99f55.js"><link rel="prefetch" href="/assets/js/99.a5ebeaa6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.18e459b6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Marvin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/t-cli/" class="nav-link">
  t-cli
</a></div><div class="nav-item"><a href="/web/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/after/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/other/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/design/" class="nav-link router-link-active">
  设计
</a></div><div class="nav-item"><a href="http://blog.canyuegongzi.xyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/canyuegongzi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  全栈项目
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/canyuegongzi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/t-cli/" class="nav-link">
  t-cli
</a></div><div class="nav-item"><a href="/web/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/after/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/other/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/design/" class="nav-link router-link-active">
  设计
</a></div><div class="nav-item"><a href="http://blog.canyuegongzi.xyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/canyuegongzi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  全栈项目
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/canyuegongzi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>微前端</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/design/microserviceWeb/overview.html" aria-current="page" class="active sidebar-link">微前端综述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端遗留系统迁移" class="sidebar-link">前端遗留系统迁移</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#后端解耦-前端聚合" class="sidebar-link">后端解耦，前端聚合</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#兼容遗留系统" class="sidebar-link">兼容遗留系统</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#基础铺垫-应用分发路由-路由分发应用" class="sidebar-link">基础铺垫：应用分发路由 -&gt; 路由分发应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#后端-函数调用-远程调用" class="sidebar-link">后端：函数调用 -&gt; 远程调用</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端-组件调用-应用调用" class="sidebar-link">前端：组件调用 -&gt; 应用调用</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#路由分发式微前端" class="sidebar-link">路由分发式微前端</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#使用-iframe-创建容器" class="sidebar-link">使用 iFrame 创建容器</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#自制框架兼容应用" class="sidebar-link">自制框架兼容应用</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#组合式集成-将应用微件化" class="sidebar-link">组合式集成：将应用微件化</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#纯-web-components-技术构建" class="sidebar-link">纯 Web Components 技术构建</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#结合-web-components-构建" class="sidebar-link">结合 Web Components 构建</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#在-web-components-中集成现有框架" class="sidebar-link">在 Web Components 中集成现有框架</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#集成在现有框架中的-web-components" class="sidebar-link">集成在现有框架中的 Web Components</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#复合型" class="sidebar-link">复合型</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#快速选型指南图" class="sidebar-link">快速选型指南图</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端方案的对比-简要对比" class="sidebar-link">微前端方案的对比：简要对比</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端方案的对比-复杂方式" class="sidebar-link">微前端方案的对比：复杂方式</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端微服化" class="sidebar-link">前端微服化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#独立开发" class="sidebar-link">独立开发</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#独立部署" class="sidebar-link">独立部署</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#我们真的需要技术无关吗" class="sidebar-link">我们真的需要技术无关吗？</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#不影响用户体验" class="sidebar-link">不影响用户体验</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端的设计理念" class="sidebar-link">微前端的设计理念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#设计理念一-中心化路由" class="sidebar-link">设计理念一：中心化路由</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#设计理念二-标识化应用" class="sidebar-link">设计理念二：标识化应用</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#设计理念三-生命周期" class="sidebar-link">设计理念三：生命周期</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#设计理念四-独立部署与配置自动化" class="sidebar-link">设计理念四：独立部署与配置自动化</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#实战微前端架构设计" class="sidebar-link">实战微前端架构设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#独立部署与配置自动化" class="sidebar-link">独立部署与配置自动化</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#应用间路由-事件" class="sidebar-link">应用间路由——事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端微服务化-路由懒加载及其变体" class="sidebar-link">前端微服务化：路由懒加载及其变体</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微服务化方案-子应用模式" class="sidebar-link">微服务化方案：子应用模式</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#方案对比" class="sidebar-link">方案对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#标准-lazyload" class="sidebar-link">标准 LazyLoad</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#lazyload-变体-1-构建时集成" class="sidebar-link">LazyLoad 变体 1：构建时集成</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#lazyload-变体-2-构建后集成" class="sidebar-link">LazyLoad 变体 2：构建后集成</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端微服务化" class="sidebar-link">前端微服务化</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#总对比" class="sidebar-link">总对比</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#mooa-概念" class="sidebar-link">Mooa 概念</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端主工程创建" class="sidebar-link">微前端主工程创建</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#mooa-子应用创建" class="sidebar-link">Mooa 子应用创建</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#导航到特定的子应用" class="sidebar-link">导航到特定的子应用</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#iframe-微服务架构设计" class="sidebar-link">iframe 微服务架构设计</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端框架-mooa-的特制-iframe-模式" class="sidebar-link">微前端框架 Mooa 的特制 iframe 模式</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端框架-mooa-iframe-通讯机制" class="sidebar-link">微前端框架 Mooa iframe 通讯机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#发布主应用事件" class="sidebar-link">发布主应用事件</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#监听子应用事件" class="sidebar-link">监听子应用事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#示例" class="sidebar-link">示例</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端遗留系统迁移-2" class="sidebar-link">前端遗留系统迁移</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#后端解耦-前端聚合-2" class="sidebar-link">后端解耦，前端聚合</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#兼容遗留系统-2" class="sidebar-link">兼容遗留系统</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#基础铺垫-应用分发路由-路由分发应用-2" class="sidebar-link">基础铺垫：应用分发路由 -&gt; 路由分发应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#后端-函数调用-远程调用-2" class="sidebar-link">后端：函数调用 -&gt; 远程调用</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端-组件调用-应用调用-2" class="sidebar-link">前端：组件调用 -&gt; 应用调用</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#路由分发式微前端-2" class="sidebar-link">路由分发式微前端</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#使用-iframe-创建容器-2" class="sidebar-link">使用 iFrame 创建容器</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#自制框架兼容应用-2" class="sidebar-link">自制框架兼容应用</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#组合式集成-将应用微件化-2" class="sidebar-link">组合式集成：将应用微件化</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#纯-web-components-技术构建-2" class="sidebar-link">纯 Web Components 技术构建</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#结合-web-components-构建-2" class="sidebar-link">结合 Web Components 构建</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#在-web-components-中集成现有框架-2" class="sidebar-link">在 Web Components 中集成现有框架</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#集成在现有框架中的-web-components-2" class="sidebar-link">集成在现有框架中的 Web Components</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#复合型-2" class="sidebar-link">复合型</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#快速选型指南图-2" class="sidebar-link">快速选型指南图</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端方案的对比-简要对比-2" class="sidebar-link">微前端方案的对比：简要对比</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端方案的对比-复杂方式-2" class="sidebar-link">微前端方案的对比：复杂方式</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端微服化-2" class="sidebar-link">前端微服化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#独立开发-2" class="sidebar-link">独立开发</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#独立部署-2" class="sidebar-link">独立部署</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#我们真的需要技术无关吗-2" class="sidebar-link">我们真的需要技术无关吗？</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#不影响用户体验-2" class="sidebar-link">不影响用户体验</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端的设计理念-2" class="sidebar-link">微前端的设计理念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#设计理念一-中心化路由-2" class="sidebar-link">设计理念一：中心化路由</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#设计理念二-标识化应用-2" class="sidebar-link">设计理念二：标识化应用</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#设计理念三-生命周期-2" class="sidebar-link">设计理念三：生命周期</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#设计理念四-独立部署与配置自动化-2" class="sidebar-link">设计理念四：独立部署与配置自动化</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#实战微前端架构设计-2" class="sidebar-link">实战微前端架构设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#独立部署与配置自动化-2" class="sidebar-link">独立部署与配置自动化</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#应用间路由-事件-2" class="sidebar-link">应用间路由——事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端微服务化-路由懒加载及其变体-2" class="sidebar-link">前端微服务化：路由懒加载及其变体</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微服务化方案-子应用模式-2" class="sidebar-link">微服务化方案：子应用模式</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#方案对比-2" class="sidebar-link">方案对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#标准-lazyload-2" class="sidebar-link">标准 LazyLoad</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#lazyload-变体-1-构建时集成-2" class="sidebar-link">LazyLoad 变体 1：构建时集成</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#lazyload-变体-2-构建后集成-2" class="sidebar-link">LazyLoad 变体 2：构建后集成</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#前端微服务化-2" class="sidebar-link">前端微服务化</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#总对比-2" class="sidebar-link">总对比</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#mooa-概念-2" class="sidebar-link">Mooa 概念</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端主工程创建-2" class="sidebar-link">微前端主工程创建</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#mooa-子应用创建-2" class="sidebar-link">Mooa 子应用创建</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#导航到特定的子应用-2" class="sidebar-link">导航到特定的子应用</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#iframe-微服务架构设计-2" class="sidebar-link">iframe 微服务架构设计</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端框架-mooa-的特制-iframe-模式-2" class="sidebar-link">微前端框架 Mooa 的特制 iframe 模式</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#微前端框架-mooa-iframe-通讯机制-2" class="sidebar-link">微前端框架 Mooa iframe 通讯机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#发布主应用事件-2" class="sidebar-link">发布主应用事件</a></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#监听子应用事件-2" class="sidebar-link">监听子应用事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/design/microserviceWeb/overview.html#示例-2" class="sidebar-link">示例</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="微前端综述"><a href="#微前端综述" class="header-anchor">#</a> 微前端综述</h1> <p>该文转载自网络，在此仅作为留存记录。</p> <blockquote><p>微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为<strong>多个小型前端应用聚合为一的应用</strong>。各个前端应用还可以<strong>独立运行</strong>、<strong>独立开发</strong>、<strong>独立部署</strong>。</p></blockquote> <p>同时，它们也可以在<strong>共享组件</strong>的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。</p> <p><strong>注意</strong>：这里的前端应用指的是前后端分离的单页面应用，在这基础才谈论微前端才有意义。</p> <p><strong>目录</strong></p> <ul><li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF">微前端的那些事儿</a></li> <li><a href="#%E5%AE%9E%E6%96%BD%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F">实施微前端的六种方式</a> <ul><li><a href="#%E5%9F%BA%E7%A1%80%E9%93%BA%E5%9E%AB%E5%BA%94%E7%94%A8%E5%88%86%E5%8F%91%E8%B7%AF%E7%94%B1---%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91%E5%BA%94%E7%94%A8">基础铺垫：应用分发路由 -&gt;
路由分发应用</a> <ul><li><a href="#%E5%90%8E%E7%AB%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8---%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8">后端：函数调用 -&gt; 远程调用</a></li> <li><a href="#%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8---%E5%BA%94%E7%94%A8%E8%B0%83%E7%94%A8">前端：组件调用 -&gt; 应用调用</a></li></ul></li> <li><a href="#%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91%E5%BC%8F%E5%BE%AE%E5%89%8D%E7%AB%AF">路由分发式微前端</a></li> <li><a href="#%E4%BD%BF%E7%94%A8-iframe-%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8">使用 iFrame 创建容器</a></li> <li><a href="#%E8%87%AA%E5%88%B6%E6%A1%86%E6%9E%B6%E5%85%BC%E5%AE%B9%E5%BA%94%E7%94%A8">自制框架兼容应用</a></li> <li><a href="#%E7%BB%84%E5%90%88%E5%BC%8F%E9%9B%86%E6%88%90%E5%B0%86%E5%BA%94%E7%94%A8%E5%BE%AE%E4%BB%B6%E5%8C%96">组合式集成：将应用微件化</a></li> <li><a href="#%E7%BA%AF-web-components-%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA">纯 Web Components 技术构建</a></li> <li><a href="#%E7%BB%93%E5%90%88-web-components-%E6%9E%84%E5%BB%BA">结合 Web Components 构建</a> <ul><li><a href="#%E5%9C%A8-web-components-%E4%B8%AD%E9%9B%86%E6%88%90%E7%8E%B0%E6%9C%89%E6%A1%86%E6%9E%B6">在 Web Components 中集成现有框架</a></li> <li><a href="#%E9%9B%86%E6%88%90%E5%9C%A8%E7%8E%B0%E6%9C%89%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84-web-components">集成在现有框架中的 Web Components</a></li></ul></li> <li><a href="#%E5%A4%8D%E5%90%88%E5%9E%8B">复合型</a></li></ul></li> <li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%BC%80%E5%A7%8B%E5%9C%A8%E6%B5%81%E8%A1%8Cweb-%E5%BA%94%E7%94%A8%E7%9A%84%E8%81%9A%E5%90%88">为什么微前端开始在流行------Web 应用的聚合</a> <ul><li><a href="#%E5%89%8D%E7%AB%AF%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB">前端遗留系统迁移</a></li> <li><a href="#%E5%90%8E%E7%AB%AF%E8%A7%A3%E8%80%A6%E5%89%8D%E7%AB%AF%E8%81%9A%E5%90%88">后端解耦，前端聚合</a></li> <li><a href="#%E5%85%BC%E5%AE%B9%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F">兼容遗留系统</a></li></ul></li> <li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%84%E5%8D%95%E4%BD%93%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%8F%E6%8B%86%E5%88%86">如何解构单体前端应用------前端应用的微服务式拆分</a> <ul><li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8C%96">前端微服化</a> <ul><li><a href="#%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91">独立开发</a></li> <li><a href="#%E7%8B%AC%E7%AB%8B%E9%83%A8%E7%BD%B2">独立部署</a></li> <li><a href="#%E6%88%91%E4%BB%AC%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%8A%80%E6%9C%AF%E6%97%A0%E5%85%B3%E5%90%97">我们真的需要技术无关吗？</a></li> <li><a href="#%E4%B8%8D%E5%BD%B1%E5%93%8D%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C">不影响用户体验</a></li></ul></li> <li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5">微前端的设计理念</a> <ul><li><a href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%80%E4%B8%AD%E5%BF%83%E5%8C%96%E8%B7%AF%E7%94%B1">设计理念一：中心化路由</a></li> <li><a href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%BA%8C%E6%A0%87%E8%AF%86%E5%8C%96%E5%BA%94%E7%94%A8">设计理念二：标识化应用</a></li> <li><a href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">设计理念三：生命周期</a></li> <li><a href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%9B%9B%E7%8B%AC%E7%AB%8B%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96">设计理念四：独立部署与配置自动化</a></li></ul></li> <li><a href="#%E5%AE%9E%E6%88%98%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">实战微前端架构设计</a> <ul><li><a href="#%E7%8B%AC%E7%AB%8B%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96">独立部署与配置自动化</a></li> <li><a href="#%E5%BA%94%E7%94%A8%E9%97%B4%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6">应用间路由------事件</a></li></ul></li></ul></li> <li><a href="#%E5%A4%A7%E5%9E%8B-angular-%E5%BA%94%E7%94%A8%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5">大型 Angular 应用微前端的四种拆分策略</a> <ul><li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93">前端微服务化：路由懒加载及其变体</a></li> <li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%96%B9%E6%A1%88%E5%AD%90%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F">微服务化方案：子应用模式</a></li> <li><a href="#%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">方案对比</a> <ul><li><a href="#%E6%A0%87%E5%87%86-lazyload">标准 LazyLoad</a></li> <li><a href="#lazyload-%E5%8F%98%E4%BD%93-1%E6%9E%84%E5%BB%BA%E6%97%B6%E9%9B%86%E6%88%90">LazyLoad 变体 1：构建时集成</a></li> <li><a href="#lazyload-%E5%8F%98%E4%BD%93-2%E6%9E%84%E5%BB%BA%E5%90%8E%E9%9B%86%E6%88%90">LazyLoad 变体 2：构建后集成</a></li> <li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96">前端微服务化</a></li></ul></li> <li><a href="#%E6%80%BB%E5%AF%B9%E6%AF%94">总对比</a></li></ul></li> <li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E4%BD%BF%E7%94%A8%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-mooa-%E5%BC%80%E5%8F%91%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8">前端微服务化：使用微前端框架 Mooa 开发微前端应用</a> <ul><li><a href="#mooa-%E6%A6%82%E5%BF%B5">Mooa 概念</a></li> <li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%BB%E5%B7%A5%E7%A8%8B%E5%88%9B%E5%BB%BA">微前端主工程创建</a></li> <li><a href="#mooa-%E5%AD%90%E5%BA%94%E7%94%A8%E5%88%9B%E5%BB%BA">Mooa 子应用创建</a></li> <li><a href="#%E5%AF%BC%E8%88%AA%E5%88%B0%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AD%90%E5%BA%94%E7%94%A8">导航到特定的子应用</a></li></ul></li> <li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E4%BD%BF%E7%94%A8%E7%89%B9%E5%88%B6%E7%9A%84-iframe-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96-angular-%E5%BA%94%E7%94%A8">前端微服务化：使用特制的 iframe 微服务化 Angular 应用</a> <ul><li><a href="#iframe-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">iframe 微服务架构设计</a></li> <li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-mooa-%E7%9A%84%E7%89%B9%E5%88%B6-iframe-%E6%A8%A1%E5%BC%8F">微前端框架 Mooa 的特制 iframe 模式</a></li> <li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-mooa-iframe-%E9%80%9A%E8%AE%AF%E6%9C%BA%E5%88%B6">微前端框架 Mooa iframe 通讯机制</a> <ul><li><a href="#%E5%8F%91%E5%B8%83%E4%B8%BB%E5%BA%94%E7%94%A8%E4%BA%8B%E4%BB%B6">发布主应用事件</a></li> <li><a href="#%E7%9B%91%E5%90%AC%E5%AD%90%E5%BA%94%E7%94%A8%E4%BA%8B%E4%BB%B6">监听子应用事件</a></li></ul></li> <li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li></ul></li> <li><a href="#%E8%B5%84%E6%BA%90">资源</a></li></ul> <h1 id="为什么微前端开始在流行-web-应用的聚合"><a href="#为什么微前端开始在流行-web-应用的聚合" class="header-anchor">#</a> 为什么微前端开始在流行——Web 应用的聚合</h1> <blockquote><p>采用新技术，更多不是因为先进，而是因为它能解决痛点。</p></blockquote> <p>过去，我一直有一个疑惑，人们是否真的需要微服务，是否真的需要微前端。毕竟，没有银弹。当人们考虑是否采用一种新的架构，除了考虑它带来好处之外，仍然也考量着存在的大量的风险和技术挑战。</p> <h2 id="前端遗留系统迁移"><a href="#前端遗留系统迁移" class="header-anchor">#</a> 前端遗留系统迁移</h2> <p>自微前端框架 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 及对应的《<a href="https://github.com/phodal/microfrontend" target="_blank" rel="noopener noreferrer">微前端的那些事儿<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》发布的两个多月以来，我陆陆续续地接收到一些微前端架构的一些咨询。过程中，我发现了一件很有趣的事：<strong>解决遗留系统，才是人们采用微前端方案最重要的原因</strong>。</p> <p>这些咨询里，开发人员所遇到的情况，与我之前遇到的情形并相似，我的场景是：设计一个新的前端架构。他们开始考虑前端微服务化，是因为遗留系统的存在。</p> <p>过去那些使用 Backbone.js、Angular.js、Vue.js 1 等等框架所编写的单页面应用，已经在线上稳定地运行着，也没有新的功能。对于这样的应用来说，我们也没有理由浪费时间和精力重写旧的应用。这里的那些使用旧的、不再使用的技术栈编写的应用，可以称为遗留系统。而，这些应用又需要结合到新应用中使用。我遇到的较多的情况是：旧的应用使用的是 Angular.js 编写，而新的应用开始采用 Angular 2+。这对于业务稳定的团队来说，是极为常见的技术栈。</p> <p>在即不重写原有系统的基础之下，又可以抽出人力来开发新的业务。其不仅仅对于业务人员来说， 是一个相当吸引力的特性；对于技术人员来说，不重写旧的业务，同时还能做一些技术上的挑战，也是一件相当有挑战的事情。</p> <h2 id="后端解耦-前端聚合"><a href="#后端解耦-前端聚合" class="header-anchor">#</a> 后端解耦，前端聚合</h2> <p>而前端微服务的一个卖点也在这里，去兼容不同类型的前端框架。这让我又联想到微服务的好处，及许多项目落地微服务的原因：</p> <p>在初期，后台微服务的一个很大的卖点在于，可以使用不同的技术栈来开发后台应用。但是，事实上，采用微服务架构的组织和机构，一般都是中大型规模的。相较于中小型，对于框架和语言的选型要求比较严格，如在内部限定了框架，限制了语言。因此，在充分使用不同的技术栈来发挥微服务的优势这一点上，几乎是很少出现的。在这些大型组织机构里，采用微服务的原因主要还是在于，<strong>使用微服务架构来解耦服务间依赖</strong>。</p> <p>而在前端微服务化上，则是恰恰与之相反的，人们更想要的结果是<strong>聚合</strong>，尤其是那些 To B（to Bussiness）的应用。</p> <p>在这两三年里，移动应用出现了一种趋势，用户不想装那么多应用了。而往往一家大的商业公司，会提供一系列的应用。这些应用也从某种程度上，反应了这家公司的组织架构。然而，在用户的眼里他们就是一家公司，他们就只应该有一个产品。相似的，这种趋势也在桌面 Web 出现。<strong>聚合</strong>成为了一个技术趋势，体现在前端的聚合就是微服务化架构。</p> <h2 id="兼容遗留系统"><a href="#兼容遗留系统" class="header-anchor">#</a> 兼容遗留系统</h2> <p>那么，在这个时候，我们就需要使用新的技术、新的架构，来容纳、兼容这些旧的应用。而前端微服务化，正好是契合人们想要的这个卖点罢了。</p> <h1 id="实施微前端的六种方式"><a href="#实施微前端的六种方式" class="header-anchor">#</a> 实施微前端的六种方式</h1> <p>微前端架构是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为<strong>多个小型前端应用聚合为一的应用</strong>。</p> <p>由此带来的变化是，这些前端应用可以<strong>独立运行</strong>、<strong>独立开发</strong>、<strong>独立部署</strong>。以及，它们应该可以在<strong>共享组件</strong>的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。</p> <p><strong>注意</strong>：这里的前端应用指的是前后端分离的单应用页面，在这基础才谈论微前端才有意义。</p> <p>结合我最近半年在<a href="https://github.com/phodal/microfrontends" target="_blank" rel="noopener noreferrer">微前端<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>方面的实践和研究来看，微前端架构一般可以由以下几种方式进行：</p> <ol><li>使用 HTTP 服务器的路由来重定向多个应用</li> <li>在不同的框架之上设计通讯、加载机制，诸如 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noopener noreferrer">Single-SPA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>通过组合多个独立应用、组件来构建一个单体应用</li> <li>iFrame。使用 iFrame 及自定义消息传递机制</li> <li>使用纯 Web Components 构建应用</li> <li>结合 Web Components 构建</li></ol> <h2 id="基础铺垫-应用分发路由-路由分发应用"><a href="#基础铺垫-应用分发路由-路由分发应用" class="header-anchor">#</a> 基础铺垫：应用分发路由 -&gt; 路由分发应用</h2> <p>在一个单体前端、单体后端应用中，有一个典型的特征，即路由是由<strong>框架</strong>来分发的，框架将路由指定到对应的组件或者内部服务中。微服务在这个过程中做的事情是，将调用由<strong>函数调用</strong>变成了<strong>远程调用</strong>，诸如远程 HTTP 调用。而微前端呢，也是类似的，它是将<strong>应用内的组件调用</strong>变成了更细粒度的<strong>应用间组件调用</strong>，即原先我们只是将路由分发到应用的组件执行，现在则需要根据路由来找到对应的应用，再由应用分发到对应的组件上。</p> <h3 id="后端-函数调用-远程调用"><a href="#后端-函数调用-远程调用" class="header-anchor">#</a> 后端：函数调用 -&gt; 远程调用</h3> <p>在大多数的 CRUD 类型的 Web 应用中，也都存在一些极为相似的模式，即：首页 -&gt; 列表 -&gt; 详情：</p> <ul><li>首页，用于面向用户展示特定的数据或页面。这些数据通常是有限个数的，并且是多种模型的。</li> <li>列表，即数据模型的聚合，其典型特点是某一类数据的集合，可以看到尽可能多的<strong>数据概要</strong>（如 Google 只返回  100 页），典型见 Google、淘宝、京东的搜索结果页。</li> <li>详情，展示一个数据的尽可能多的内容。</li></ul> <p>如下是一个 Spring 框架，用于返回首页的示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">homePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token string">&quot;/WEB-INF/jsp/index.jsp&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于某个详情页面来说，它可能是这样的：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;/detail/{detailId}&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">detail</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ModelMap</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token string">&quot;/WEB-INF/jsp/detail.jsp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;detail&quot;</span><span class="token punctuation">,</span> detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么，在微服务的情况下，它则会变成这样子：</p> <div class="language- extra-class"><pre class="language-text"><code>@RequestMapping(&quot;/name&quot;)
public String name(){
    String name = restTemplate.getForObject(&quot;http://account/name&quot;, String.class);
    return Name&quot; + name;
}
</code></pre></div><p>而后端在这个过程中，多了一个服务发现的服务，来管理不同微服务的关系。</p> <h3 id="前端-组件调用-应用调用"><a href="#前端-组件调用-应用调用" class="header-anchor">#</a> 前端：组件调用 -&gt; 应用调用</h3> <p>在形式上来说，单体前端框架的路由和单体后端应用，并没有太大的区别：<strong>依据不同的路由，来返回不同页面的模板。</strong></p> <div class="language-javascritp extra-class"><pre class="language-text"><code>const appRoutes: Routes = [
  { path: 'index', component: IndexComponent },
  { path: 'detail/:id', component: DetailComponent },
];
</code></pre></div><p>而当我们将之微服务化后，则可能变成应用 A 的路由：</p> <div class="language-javascritp extra-class"><pre class="language-text"><code>const appRoutes: Routes = [
  { path: 'index', component: IndexComponent },
];
</code></pre></div><p>外加之应用 B 的路由：</p> <div class="language-javascritp extra-class"><pre class="language-text"><code>const appRoutes: Routes = [
  { path: 'detail/:id', component: DetailComponent },
];
</code></pre></div><p>而问题的关键就在于：<strong>怎么将路由分发到这些不同的应用中去</strong>。与此同时，还要负责管理不同的前端应用。</p> <h2 id="路由分发式微前端"><a href="#路由分发式微前端" class="header-anchor">#</a> 路由分发式微前端</h2> <p><strong>路由分发式微前端</strong>，即通过路由将不同的业务<strong>分发到不同的、独立前端应用</strong>上。其通常可以通过 HTTP 服务器的反向代理来实现，又或者是应用框架自带的路由来解决。</p> <p>就当前而言，通过路由分发式的微前端架构应该是采用最多、最易采用的 “微前端” 方案。但是这种方式看上去更像是<strong>多个前端应用的聚合</strong>，即我们只是将这些不同的前端应用拼凑到一起，使他们看起来像是一个完整的整体。但是它们并不是，每次用户从 A 应用到 B 应用的时候，往往需要刷新一下页面。</p> <p>在几年前的一个项目里，我们当时正在进行<strong>遗留系统重写</strong>。我们制定了一个迁移计划：</p> <ol><li>首先，使用<strong>静态网站生成</strong>动态生成首页</li> <li>其次，使用 React 计划栈重构详情页</li> <li>最后，替换搜索结果页</li></ol> <p>整个系统并不是一次性迁移过去，而是一步步往下进行。因此在完成不同的步骤时，我们就需要上线这个功能，于是就需要使用 Nginx 来进行路由分发。</p> <p>如下是一个基于路由分发的 Nginx 配置示例：</p> <div class="language- extra-class"><pre class="language-text"><code>http {
  server {
    listen       80;
    server_name  www.phodal.com;
    location /api/ {
      proxy_pass http://http://172.31.25.15:8000/api;
    }
    location /web/admin {
      proxy_pass http://172.31.25.29/web/admin;
    }
    location /web/notifications {
      proxy_pass http://172.31.25.27/web/notifications;
    }
    location / {
      proxy_pass /;
    }
  }
}
</code></pre></div><p>在这个示例里，不同的页面的请求被分发到不同的服务器上。</p> <p>随后，我们在别的项目上也使用了类似的方式，其主要原因是：<strong>跨团队的协作</strong>。当团队达到一定规模的时候，我们不得不面对这个问题。除此，还有 Angluar 跳崖式升级的问题。于是，在这种情况下，用户前台使用 Angular 重写，后台继续使用 Angular.js 等保持再有的技术栈。在不同的场景下，都有一些相似的技术决策。</p> <p>因此在这种情况下，它适用于以下场景：</p> <ul><li>不同技术栈之间差异比较大，难以兼容、迁移、改造</li> <li>项目不想花费大量的时间在这个系统的改造上</li> <li>现有的系统在未来将会被取代</li> <li>系统功能已经很完善，基本不会有新需求</li></ul> <p>而在满足上面场景的情况下，如果为了更好的用户体验，还可以采用 iframe 的方式来解决。</p> <h2 id="使用-iframe-创建容器"><a href="#使用-iframe-创建容器" class="header-anchor">#</a> 使用 iFrame 创建容器</h2> <p>iFrame 作为一个非常古老的，人人都觉得普通的技术，却一直很管用。</p> <blockquote><p><strong>HTML 内联框架元素</strong> <code>&lt;iframe&gt;</code> 表示嵌套的正在浏览的上下文，能有效地将另一个 HTML 页面嵌入到当前页面中。</p></blockquote> <p>iframe 可以创建一个全新的独立的宿主环境，这意味着我们的前端应用之间可以相互独立运行。采用 iframe 有几个重要的前提：</p> <ul><li>网站不需要 SEO 支持</li> <li>拥有相应的<strong>应用管理机制</strong>。</li></ul> <p>如果我们做的是一个应用平台，会在我们的系统中集成第三方系统，或者多个不同部门团队下的系统，显然这是一个不错的方案。一些典型的场景，如传统的 Desktop 应用迁移到 Web 应用：</p> <p><img src="/assets/img/angular-tabs-example.65ab370b.png" alt="Angular Tabs 示例"></p> <p>如果这一类应用过于复杂，那么它必然是要进行微服务化的拆分。因此，在采用 iframe 的时候，我们需要做这么两件事：</p> <ul><li>设计<strong>管理应用机制</strong></li> <li>设计<strong>应用通讯机制</strong></li></ul> <p><strong>加载机制</strong>。在什么情况下，我们会去加载、卸载这些应用；在这个过程中，采用怎样的动画过渡，让用户看起来更加自然。</p> <p><strong>通讯机制</strong>。直接在每个应用中创建 <code>postMessage</code> 事件并监听，并不是一个友好的事情。其本身对于应用的侵入性太强，因此通过 <code>iframeEl.contentWindow</code> 去获取 iFrame 元素的 Window 对象是一个更简化的做法。随后，就需要<strong>定义一套通讯规范</strong>：事件名采用什么格式、什么时候开始监听事件等等。</p> <p>有兴趣的读者，可以看看笔者之前写的微前端框架：<a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>不管怎样，iframe 对于我们今年的 KPI 怕是带不来一丝的好处，那么我们就去造个轮子吧。</p> <h2 id="自制框架兼容应用"><a href="#自制框架兼容应用" class="header-anchor">#</a> 自制框架兼容应用</h2> <p>不论是基于 Web Components 的 Angular，或者是 VirtualDOM 的 React 等，现有的前端框架都离不开基本的 HTML 元素 DOM。</p> <p>那么，我们只需要：</p> <ol><li>在页面合适的地方引入或者创建 DOM</li> <li>用户操作时，加载对应的应用（触发应用的启动），并能卸载应用。</li></ol> <p>第一个问题，创建 DOM 是一个容易解决的问题。而第二个问题，则一点儿不容易，特别是移除 DOM 和相应应用的监听。当我们拥有一个不同的技术栈时，我们就需要有针对性设计出一套这样的逻辑。</p> <p>尽管 <a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noopener noreferrer">Single-SPA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 已经拥有了大部分框架（如 React、Angular、Vue 等框架）的启动和卸载处理，但是它仍然不是适合于生产用途。当我基于 Single-SPA 为 Angular 框架设计一个微前端架构的应用时，我最后选择重写一个自己的框架，即 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>虽然，这种方式的上手难度相对比较高，但是后期订制及可维护性比较方便。在不考虑每次加载应用带来的用户体验问题，其唯一存在的风险可能是：<strong>第三方库不兼容</strong>。</p> <p>但是，不论怎样，与 iFrame 相比，其在技术上更具有<strong>可吹牛逼性</strong>，更有看点。同样的，与 iframe 类似，我们仍然面对着一系列的不大不小的问题：</p> <ul><li>需要设计一套管理应用的机制。</li> <li>对于流量大的 toC 应用来说，会在首次加载的时候，会多出大量的请求</li></ul> <p>而我们即又要拆分应用，又想 blabla……，我们还能怎么做？</p> <h2 id="组合式集成-将应用微件化"><a href="#组合式集成-将应用微件化" class="header-anchor">#</a> 组合式集成：将应用微件化</h2> <p><strong>组合式集成</strong>，即通过<strong>软件工程</strong>的方式在构建前、构建时、构建后等步骤中，对应用进行一步的拆分，并重新组合。</p> <p>从这种定义上来看，它可能算不上并不是一种微前端——它可以满足了微前端的三个要素，即：<strong>独立运行</strong>、<strong>独立开发</strong>、<strong>独立部署</strong>。但是，配合上前端框架的组件 Lazyload 功能——即在需要的时候，才加载对应的业务组件或应用，它看上去就是一个微前端应用。</p> <p>与此同时，由于所有的依赖、Pollyfill 已经尽可能地在首次加载了，CSS 样式也不需要重复加载。</p> <p>常见的方式有：</p> <ul><li>独立构建组件和应用，生成 chunk 文件，构建后再<strong>归类</strong>生成的 chunk 文件。（这种方式更类似于微服务，但是成本更高）</li> <li>开发时独立开发组件或应用，集成时合并组件和应用，最后生成单体的应用。</li> <li>在运行时，加载应用的 Runtime，随后加载对应的应用代码和模板。</li></ul> <p>应用间的关系如下图所示（其忽略图中的 “前端微服务化”）：</p> <p><img src="/assets/img/angular-split-code-compare.92481961.jpg" alt="组合式集成对比"></p> <p>这种方式看上去相当的理想，即能满足多个团队并行开发，又能构建出适合的交付物。</p> <p>但是，首先它有一个严重的限制：<strong>必须使用同一个框架</strong>。对于多数团队来说，这并不是问题。采用微服务的团队里，也不会因为微服务这一个前端，来使用不同的语言和技术来开发。当然了，如果要使用别的框架，也不是问题，我们只需要结合上一步中的<strong>自制框架兼容应用</strong>就可以满足我们的需求。</p> <p>其次，采用这种方式还有一个限制，那就是：<strong>规范！****规范！****规范！</strong>。在采用这种方案时，我们需要：</p> <ul><li>统一依赖。统一这些依赖的版本，引入新的依赖时都需要一一加入。</li> <li>规范应用的组件及路由。避免不同的应用之间，因为这些组件名称发生冲突。</li> <li>构建复杂。在有些方案里，我们需要修改构建系统，有些方案里则需要复杂的架构脚本。</li> <li>共享通用代码。这显然是一个要经常面对的问题。</li> <li>制定代码规范。</li></ul> <p>因此，这种方式看起来更像是一个软件工程问题。</p> <p>现在，我们已经有了四种方案，每个方案都有自己的利弊。显然，结合起来会是一种更理想的做法。</p> <p>考虑到现有及常用的技术的局限性问题，让我们再次将目光放得长远一些。</p> <h2 id="纯-web-components-技术构建"><a href="#纯-web-components-技术构建" class="header-anchor">#</a> 纯 Web Components 技术构建</h2> <p>在学习 Web Components 开发微前端架构的过程中，我尝试去写了我自己的 Web Components 框架：<a href="https://github.com/phodal/oan" target="_blank" rel="noopener noreferrer">oan<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。在添加了一些基本的 Web 前端框架的功能之后，我发现这项技术特别适合于<strong>作为微前端的基石</strong>。</p> <blockquote><p>Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 Web 应用中使用它们。</p></blockquote> <p>它主要由四项技术组件：</p> <ul><li>Custom elements，允许开发者创建自定义的元素，诸如 <today-news></today-news>。</li> <li>Shadow DOM，即影子 DOM，通常是将 Shadow DOM 附加到主文档 DOM 中，并可以控制其关联的功能。而这个 Shadow DOM 则是不能直接用其它主文档 DOM 来控制的。</li> <li>HTML templates，即 <code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素，用于编写不在页面中显示的标记模板。</li> <li>HTML Imports，用于引入自定义组件。</li></ul> <p>每个组件由 <code>link</code> 标签引入：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;link rel=&quot;import&quot; href=&quot;components/di-li.html&quot;&gt;
&lt;link rel=&quot;import&quot; href=&quot;components/d-header.html&quot;&gt;
</code></pre></div><p>随后，在各自的 HTML 文件里，创建相应的组件元素，编写相应的组件逻辑。一个典型的 Web Components 应用架构如下图所示：</p> <p><img src="/assets/img/web-components-architecture.a9eeefba.png" alt="Web Components 架构"></p> <p>可以看到这边方式与我们上面使用 iframe 的方式很相似，组件拥有自己独立的 <code>Scripts</code> 和 <code>Styles</code>，以及对应的用于单独部署组件的域名。然而它并没有想象中的那么美好，要直接使用<strong>纯</strong> Web Components 来构建前端应用的难度有：</p> <ul><li>重写现有的前端应用。是的，现在我们需要完成使用 Web Components 来完成整个系统的功能。</li> <li>上下游生态系统不完善。缺乏相应的一些第三方控件支持，这也是为什么 jQuery 相当流行的原因。</li> <li>系统架构复杂。当应用被拆分为一个又一个的组件时，组件间的通讯就成了一个特别大的麻烦。</li></ul> <p>Web Components 中的 ShadowDOM 更像是新一代的前端 DOM 容器。而遗憾的是并不是所有的浏览器，都可以完全支持 Web Components。</p> <h2 id="结合-web-components-构建"><a href="#结合-web-components-构建" class="header-anchor">#</a> 结合 Web Components 构建</h2> <p>Web Components 离现在的我们太远，可是结合 Web Components 来构建前端应用，则更是一种面向未来演进的架构。或者说在未来的时候，我们可以开始采用这种方式来构建我们的应用。好在，已经有框架在打造这种可能性。</p> <p>就当前而言，有两种方式可以结合 Web Components 来构建微前端应用：</p> <ul><li>使用 Web Components 构建独立于框架的组件，随后在对应的框架中引入这些组件</li> <li>在 Web Components 中引入现有的框架，类似于 iframe 的形式</li></ul> <p>前者是一种组件式的方式，或者则像是在迁移未来的 “遗留系统” 到未来的架构上。</p> <h3 id="在-web-components-中集成现有框架"><a href="#在-web-components-中集成现有框架" class="header-anchor">#</a> 在 Web Components 中集成现有框架</h3> <p>现有的 Web 框架已经有一些可以支持 Web Components 的形式，诸如 Angular 支持的 createCustomElement，就可以实现一个 Web Components 形式的组件：</p> <div class="language- extra-class"><pre class="language-text"><code>platformBrowser()
  .bootstrapModuleFactory(MyPopupModuleNgFactory)
    .then(({injector}) =&gt; {
      const MyPopupElement = createCustomElement(MyPopup, {injector});
      customElements.define(‘my-popup’, MyPopupElement);
});
</code></pre></div><p>在未来，将有更多的框架可以使用类似这样的形式，集成到 Web Components 应用中。</p> <h3 id="集成在现有框架中的-web-components"><a href="#集成在现有框架中的-web-components" class="header-anchor">#</a> 集成在现有框架中的 Web Components</h3> <p>另外一种方式，则是类似于 <a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener noreferrer">Stencil<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的形式，将组件直接构建成 Web Components 形式的组件，随后在对应的诸如，如 React 或者 Angular 中直接引用。</p> <p>如下是一个在 React 中引用 Stencil 生成的 Web Components 的例子：</p> <div class="language-javascriptA extra-class"><pre class="language-text"><code>import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

import 'test-components/testcomponents';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
registerServiceWorker();
</code></pre></div><p>在这种情况之下，我们就可以构建出独立于框架的组件。</p> <p>同样的 Stencil 仍然也只是支持最近的一些浏览器，比如：Chrome、Safari、Firefox、Edge 和 IE11</p> <h2 id="复合型"><a href="#复合型" class="header-anchor">#</a> 复合型</h2> <p><strong>复合型</strong>，对就是上面的几个类别中，随便挑几种组合到一起。</p> <p>我就不废话了~~。</p> <h1 id="微前端架构选型指南"><a href="#微前端架构选型指南" class="header-anchor">#</a> 微前端架构选型指南</h1> <p>在上一节《实施前端微服务化的六七种方式》中，介绍了在实施微前端的过程中，我们采用的一些不同方案的架构方案。在这篇文章中，我将总结如何依据不同的情况来选择合适的方案。</p> <h2 id="快速选型指南图"><a href="#快速选型指南图" class="header-anchor">#</a> 快速选型指南图</h2> <p>我还是直接先给结论：</p> <p><img src="/assets/img/choice-your-microservices.8a002c9b.png" alt="微前端选型指南"></p> <p>关键点的相关解释如下：</p> <p><strong>框架限制</strong>。在后台微服务系统里，人们使用其它语言的库来开发新的服务，如用于人工智能的 Python。但是在前端，几乎不存在这种可能性。所以当我们的前端框架只有一个时，我们在采用微前端的技术时，可选范围就更大了。而遗憾的是，多数组织需要兼容遗留系统。</p> <p><strong>IE 问题</strong>。不论是在几年前，还是在今年，我们实施微前端最先考虑的就是对于 IE 的支持。在我遇到的项目上，基本上都需要支持 IE，因此在技术选型上就受限一定的限制。而在我们那些不需要支持 IE 的项目上，他们就可以使用 WebComponents 技术来构建微前端应用。</p> <p><strong>依赖独立</strong>。即各个微前端应用的依赖是要统一管理，还是要在各个应该中自己管理。统一管理可以解决重复加载依赖的问题，独立管理会带来额外的流量开销和等待时间。</p> <h2 id="微前端方案的对比-简要对比"><a href="#微前端方案的对比-简要对比" class="header-anchor">#</a> 微前端方案的对比：简要对比</h2> <p>如果你对上述的几个方面，仍然不是很熟悉的话，请阅读《实施前端微服务化的六七种方式》。</p> <table><thead><tr><th>方式</th> <th>开发成本</th> <th>维护成本</th> <th>可行性</th> <th>同一框架要求</th> <th>实现难度</th> <th>潜在风险</th></tr></thead> <tbody><tr><td>路由分发</td> <td>低</td> <td>低</td> <td>高</td> <td>否</td> <td>★</td> <td>这个方案太普通了</td></tr> <tr><td>iFrame</td> <td>低</td> <td>低</td> <td>高</td> <td>否</td> <td>★</td> <td>这个方案太普通了</td></tr> <tr><td>应用微服务化</td> <td>高</td> <td>低</td> <td>中</td> <td>否</td> <td>★★★★</td> <td>针对每个框架做定制及 Hook</td></tr> <tr><td>微件化</td> <td>高</td> <td>中</td> <td>低</td> <td>是</td> <td>★★★★★</td> <td>针对构建系统，如 webpack 进行 hack</td></tr> <tr><td>微应用化</td> <td>中</td> <td>中</td> <td>高</td> <td>是</td> <td>★★★</td> <td>统一不同应用的构建规范</td></tr> <tr><td>纯 Web Components</td> <td>高</td> <td>低</td> <td>高</td> <td>否</td> <td>★★</td> <td>新技术，浏览器的兼容问题</td></tr> <tr><td>结合 Web Components</td> <td>高</td> <td>低</td> <td>高</td> <td>否</td> <td>★★</td> <td>新技术，浏览器的兼容问题</td></tr></tbody></table> <p>同样的，一些复杂概念的解释如下：</p> <p><strong>应用微服务化</strong>，即每个前端应用一个独立的服务化前端应用，并配套一套统一的应用管理和启动机制，诸如微前端框架 Single-SPA 或者 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p> <p><strong>微件化</strong>，即通过对构建系统的 hack，使不同的前端应用可以使用同一套依赖。它在<strong>应用微服务化</strong>的基本上，改进了重复加载依赖文件的问题。</p> <p><strong>微应用化</strong>，又可以称之为<strong>组合式集成</strong>，即通过软件工程的方式，在开发环境对单体应用进行拆分，在构建环境将应用组合在一起构建成一个应用。详细的细节，可以期待后面的文章《一个单体前端应用的拆解与微服务化》</p> <h2 id="微前端方案的对比-复杂方式"><a href="#微前端方案的对比-复杂方式" class="header-anchor">#</a> 微前端方案的对比：复杂方式</h2> <p>之前看到一篇微服务相关的 <a href="https://www.softwarearchitekt.at/post/2017/12/28/a-software-architect-s-approach-towards-using-angular-and-spas-in-general-for-microservices-aka-microfrontends.aspx" target="_blank" rel="noopener noreferrer">文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，介绍了不同微服务的区别，其采用了一种比较有意思的对比方式特别详细，这里就使用同样的方式来展示：</p> <table><thead><tr><th>架构目标</th> <th>描述</th></tr></thead> <tbody><tr><td>a. 独立开发</td> <td>独立开发，而不受影响</td></tr> <tr><td>b. 独立部署</td> <td>能作为一个服务来单独部署</td></tr> <tr><td>c. 支持不同框架</td> <td>可以同时使用不同的框架，如 Angular、Vue、React</td></tr> <tr><td>d. 摇树优化</td> <td>能消除未使用的代码</td></tr> <tr><td>e. 环境隔离</td> <td>应用间的上下文不受干扰</td></tr> <tr><td>f. 多个应用同时运行</td> <td>不同应用可以同时运行</td></tr> <tr><td>g. 共用依赖</td> <td>不同应用是否共用底层依赖库</td></tr> <tr><td>h. 依赖冲突</td> <td>依赖的不同版本是否导致冲突</td></tr> <tr><td>i. 集成编译</td> <td>应用最后被编译成一个整体，而不是分开构建</td></tr></tbody></table> <p>那么，对于下表而言，表中的 a~j 分别表示上面的几种不同的架构考虑因素。</p> <p>（PS：考虑到  Web Components 几个单词的长度，暂时将它简称为 WC~~)</p> <table><thead><tr><th>方式</th> <th>a</th> <th>b</th> <th>c</th> <th>d</th> <th>e</th> <th>f</th> <th>g</th> <th>h</th> <th>i</th></tr></thead> <tbody><tr><td>路由分发</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td></td> <td></td> <td></td></tr> <tr><td>iFrame</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td></td> <td></td> <td></td></tr> <tr><td>应用微服务化</td> <td>O</td> <td>O</td> <td>O</td> <td></td> <td></td> <td>O</td> <td></td> <td></td> <td></td></tr> <tr><td>微件化</td> <td>O</td> <td>O</td> <td></td> <td></td> <td>-</td> <td>-</td> <td>O</td> <td>-</td> <td></td></tr> <tr><td>微应用化</td> <td>O</td> <td>O</td> <td></td> <td>O</td> <td>-</td> <td>-</td> <td>O</td> <td>-</td> <td>O</td></tr> <tr><td>纯 WC</td> <td>O</td> <td>O</td> <td></td> <td>O</td> <td>O</td> <td>O</td> <td>-</td> <td>-</td> <td>O</td></tr> <tr><td>结合 WC</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td></td> <td></td> <td>O</td></tr></tbody></table> <p>图中的 O 表示支持，空白表示不支持，- 表示不受影响。</p> <p>再结合之前的选型指南：</p> <p><img src="/assets/img/choice-your-microservices.8a002c9b.png" alt="微前端选型指南"></p> <p>（PS：本图采用 Keynote 绘制）</p> <p>你是否找到你想到的架构了？</p> <h1 id="如何解构单体前端应用-前端应用的微服务式拆分"><a href="#如何解构单体前端应用-前端应用的微服务式拆分" class="header-anchor">#</a> 如何解构单体前端应用——前端应用的微服务式拆分</h1> <blockquote><p>刷新页面？路由拆分？No，动态加载组件。</p></blockquote> <p>本文分为以下四部分：</p> <ul><li>前端微服务化思想介绍</li> <li>微前端的设计理念</li> <li>实战微前端架构设计</li> <li>基于 Mooa 进行前端微服务化</li></ul> <h2 id="前端微服化"><a href="#前端微服化" class="header-anchor">#</a> 前端微服化</h2> <p>对于前端微服化来说，有这么一些方案：</p> <ul><li>Web Component 显然可以一个很优秀的基础架构。然而，我们并不可能去大量地复写已有的应用。</li> <li>iFrame。你是说真的吗？</li> <li>另外一个微前端框架 Single-SPA，显然是一个更好的方式。然而，它并非 Production Ready。</li> <li>通过路由来切分应用，而这个跳转会影响用户体验。</li> <li>等等。</li></ul> <p>因此，当我们考虑前端微服务化的时候，我们希望：</p> <ul><li>独立部署</li> <li>独立开发</li> <li>技术无关</li> <li>不影响用户体验</li></ul> <h3 id="独立开发"><a href="#独立开发" class="header-anchor">#</a> 独立开发</h3> <p>在过去的几星期里，我花费了大量的时间在学习 Single-SPA 的代码。但是，我发现它在开发和部署上真的太麻烦了，完全达不到独立部署地标准。按 Single-SPA 的设计，我需要在入口文件中声名我的应用，然后才能去构建：</p> <div class="language- extra-class"><pre class="language-text"><code>declareChildApplication('inferno', () =&gt; import('src/inferno/inferno.app.js'), pathPrefix('/inferno'));
</code></pre></div><p>同时，在我的应用里，我还需要去指定我的生命周期。这就意味着，当我开发了一个新的应用时，必须更新两份代码：主工程和应用。这时我们还极可能在同一个源码里工作。</p> <p>当出现多个团队的时候，在同一份源码里工作，显然变得相当的不可靠——比如说，对方团队使用的是 Tab，而我们使用的是 2 个空格，隔壁的老王用的是 4 个空格。</p> <h3 id="独立部署"><a href="#独立部署" class="header-anchor">#</a> 独立部署</h3> <p>一个单体的前端应用最大的问题是，构建出来的 js、css 文件相当的巨大。而微前端则意味着，这个文件被独立地拆分成多个文件，它们便可以独立去部署应用。</p> <h3 id="我们真的需要技术无关吗"><a href="#我们真的需要技术无关吗" class="header-anchor">#</a> 我们真的需要技术无关吗？</h3> <p>等等，我们是否真的需要<strong>技术无关</strong>？如果我们不需要技术无关的话，微前端问题就很容易解决了。</p> <p>事实上，对于大部分的公司和团队来说，技术无关只是一个无关痛痒的话术。当一家公司的几个创始人使用了 Java，那么极有可能在未来的选型上继续使用 Java。除非，一些额外的服务来使用 Python 来实现人工智能。因此，在大部分的情况下，仍然是技术栈唯一。</p> <p>对于前端项目来说，更是如此：一个部门里基本上只会选用一个框架。</p> <p>于是，我们选择了 Angular。</p> <h3 id="不影响用户体验"><a href="#不影响用户体验" class="header-anchor">#</a> 不影响用户体验</h3> <p>使用路由跳转来进行前端微服务化，是一种很简单、高效的切分方式。然而，路由跳转地过程中，会有一个白屏的过程。在这个过程中，跳转前的应用和将要跳转的应用，都失去了对页面的控制权。如果这个应用出了问题，那么用户就会一脸懵逼。</p> <p>理想的情况下，它应该可以被控制。</p> <h2 id="微前端的设计理念"><a href="#微前端的设计理念" class="header-anchor">#</a> 微前端的设计理念</h2> <h3 id="设计理念一-中心化路由"><a href="#设计理念一-中心化路由" class="header-anchor">#</a> 设计理念一：中心化路由</h3> <p>互联网本质是去中心化的吗？不，DNS 决定了它不是。TAB，决定了它不是。</p> <p>微服务从本质上来说，它应该是去中心化的。但是，它又不能是完全的去中心化。对于一个微服务来说，它需要一个<strong>服务注册中心</strong>：</p> <blockquote><p>服务提供方要注册通告服务地址，服务的调用方要能发现目标服务。</p></blockquote> <p>对于一个前端应用来说，这个东西就是路由。</p> <p>从页面上来说，只有我们在网页上添加一个菜单链接，用户才能知道某个页面是可以使用的。</p> <p>而从代码上来说，那就是我们需要有一个地方来管理我们的应用：**发现存在哪些应用，哪个应用使用哪个路由。</p> <p><strong>管理好我们的路由，实际上就是管理好我们的应用</strong>。</p> <h3 id="设计理念二-标识化应用"><a href="#设计理念二-标识化应用" class="header-anchor">#</a> 设计理念二：标识化应用</h3> <p>在设计一个微前端框架的时候，为<strong>每个项目取一个名字的</strong>问题纠结了我很久——怎么去规范化这个东西。直到，我再一次想到了康威定律：</p> <blockquote><p>系统设计(产品结构等同组织形式，每个设计系统的组织，其产生的设计等同于组织之间的沟通结构。</p></blockquote> <p>换句人话说，就是同一个组织下，不可能有两个项目的名称是一样的。</p> <p>所以，这个问题很简单就解决了。</p> <h3 id="设计理念三-生命周期"><a href="#设计理念三-生命周期" class="header-anchor">#</a> 设计理念三：生命周期</h3> <p>Single-SPA 设计了一个基本的生命周期（虽然它没有统一管理），它包含了五种状态：</p> <ul><li>load，决定加载哪个应用，并绑定生命周期</li> <li>bootstrap，获取静态资源</li> <li>mount，安装应用，如创建 DOM 节点</li> <li>unload，删除应用的生命周期</li> <li>unmount，卸载应用，如删除 DOM 节点</li></ul> <p>于是，我在设计上基本上沿用了这个生命周期。显然，诸如 load 之类对于我的设计是多余的。</p> <h3 id="设计理念四-独立部署与配置自动化"><a href="#设计理念四-独立部署与配置自动化" class="header-anchor">#</a> 设计理念四：独立部署与配置自动化</h3> <p>从某种意义上来说，整个每系统是围绕着应用配置进行的。如果应用的配置能自动化，那么整个系统就自动化。</p> <p>当我们只开发一个新的组件，那么我们只需要更新我们的组件，并更新配置即可。而这个配置本身也应该是能自动生成的。</p> <h2 id="实战微前端架构设计"><a href="#实战微前端架构设计" class="header-anchor">#</a> 实战微前端架构设计</h2> <p>基于以上的前提，系统的工作流程如下所示：</p> <p><img src="/assets/img/mooa-graph.7272c84d.jpg" alt="系统工作流"></p> <p>整体的工程流程如下所示：</p> <ol><li>主工程在运行的时候，会去服务器获取最新的应用配置。</li> <li>主工程在获取到配置后，将一一创建应用，并为应用绑定生命周期。</li> <li>当主工程监测到路由变化的时候，将寻找是否有对应的路由匹配到应用。</li> <li>当匹配对对应应用时，则加载相应的应用。</li></ol> <p>故而，其对应的结构下图所示：</p> <p><img src="/assets/img/mooa-app.5053c432.jpg" alt="Architecture"></p> <p>整体的流程如下图所示：</p> <p><img src="/assets/img/workflow.83c7eccf.png" alt="Workflow"></p> <h3 id="独立部署与配置自动化"><a href="#独立部署与配置自动化" class="header-anchor">#</a> 独立部署与配置自动化</h3> <p>我们做的部署策略如下：我们的应用使用的配置文件叫 <code>apps.json</code>，由主工程去获取这个配置。每次部署的时候，我们只需要将 <code>apps.json</code> 指向最新的配置文件即可。配置的文件类如下所示：</p> <ol><li>96a7907e5488b6bb.json</li> <li>6ff3bfaaa2cd39ea.json</li> <li>dcd074685c97ab9b.json</li></ol> <p>一个应用的配置如下所示：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;help&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;selector&quot;</span><span class="token operator">:</span> <span class="token string">&quot;help-root&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;baseScriptUrl&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/assets/help&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;styles&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;styles.bundle.css&quot;</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">&quot;prefix&quot;</span><span class="token operator">:</span> <span class="token string">&quot;help&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;inline.bundle.js&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;polyfills.bundle.js&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;main.bundle.js&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的 <code>selector</code> 对应于应用所需要的 DOM 节点，prefix 则是用于 URL 路由上。这些都是自动从 <code>index.html</code> 文件和 <code>package.json</code> 中获取生成的。</p> <h3 id="应用间路由-事件"><a href="#应用间路由-事件" class="header-anchor">#</a> 应用间路由——事件</h3> <p>由于现在的应用变成了两部分：主工程和应用部分。就会出现一个问题：<strong>只有一个工程能捕获路由变化</strong>。当由主工程去改变应用的二级路由时，就无法有效地传达到子应用。在这时，只能通过事件的方式去通知子应用，子应用也需要监测是否是当前应用的路由。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>app<span class="token punctuation">.</span>name <span class="token operator">===</span> appName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> urlPrefix <span class="token operator">=</span> <span class="token string">'app'</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>urlPrefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    urlPrefix <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>window<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span>option<span class="token punctuation">.</span>urlPrefix<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span>
  router<span class="token punctuation">.</span><span class="token function">navigate</span><span class="token punctuation">(</span><span class="token punctuation">[</span>event<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>urlPrefix <span class="token operator">+</span> appName<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>相似的，当我们需要从应用 A 跳转到应用 B 时，我们也需要这样的一个机制：</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('mooa.routing.navigate', function(event: CustomEvent) {
  const opts = event.detail
  if (opts) {
    navigateAppByName(opts)
  }
})
</code></pre></div><p>剩下的诸如 Loading 动画也是类似的。</p> <h1 id="大型-angular-应用微前端的四种拆分策略"><a href="#大型-angular-应用微前端的四种拆分策略" class="header-anchor">#</a> 大型 Angular 应用微前端的四种拆分策略</h1> <p>上一个月，我们花了大量的时间不熂设计方案来拆分一个大型的 Angular 应用。从使用 Angular 的 Lazyload 到前端微服务化，进行了一系列的讨论。最后，我们终于有了结果，采用的是 Lazyload 变体：<strong>构建时集成代码</strong> 的方式。</p> <p>过去的几周里，作为一个 “专业” 的咨询师，一直忙于在为客户设计一个 Angular 拆分的服务化方案。主要是为了达成以下的设计目标：</p> <ul><li>构建插件化的 Web 开发平台，满足业务快速变化及分布式多团队并行开发的需求</li> <li>构建服务化的中间件，搭建高可用及高复用的前端微服务平台</li> <li>支持前端的独立交付及部署</li></ul> <p>简单地来说，就是要支持<strong>应用插件化开发</strong>，以及<strong>多团队并行开发</strong>。</p> <p><strong>应用插件化开发</strong>，其所要解决的主要问题是：臃肿的大型应用的拆分问题。大型前端应用，在开发的时候要面临大量的<strong>遗留代码</strong>、不同业务的代码耦合在一起，在线上的时候还要面临加载速度慢，运行效率低的问题。</p> <p>最后就落在了两个方案上：路由懒加载及其变体与前端微服务化</p> <h2 id="前端微服务化-路由懒加载及其变体"><a href="#前端微服务化-路由懒加载及其变体" class="header-anchor">#</a> 前端微服务化：路由懒加载及其变体</h2> <p>路由懒加载，即通过不同的路由来将应用切成不同的代码快，当路由被访问的时候，才加载对应组件。在诸如 Angular、Vue 框架里都可以通过路由 +  Webpack 打包的方式来实现。而，不可避免地就会需要一些问题：</p> <p><strong>难以多团队并行开发</strong>，路由拆分就意味着我们仍然是在一个源码库里工作的。也可以尝试拆分成不同的项目，再编译到一起。</p> <p><strong>每次发布需要重新编译</strong>，是的，当我们只是更新一个子模块的代码，我们要重新编译整个应用，再重新发布这个应用。而不能独立地去构建它，再发布它。</p> <p><strong>统一的 Vendor 版本</strong>，统一第三方依赖是一件好事。可问题的关键在于：每当我们添加一个新的依赖，我们可能就需要开会讨论一下。</p> <p>然而，标准 Route Lazyload 最大的问题就是<strong>难以多团队并行开发</strong>，这里之所以说的是 “难以” 是因为，还是有办法解决这个问题。在日常的开发中，一个小的团队会一直在一个代码库里开发，而一个大的团队则应该是在不同的代码库里开发。</p> <p>于是，我们在标准的路由懒加载之上做了一些尝试。</p> <p>对于一个二三十人规模的团队来说，他们可能在业务上归属于不同的部门，技术上也有一些不一致的规范，如 4 个空格、2 个空格还是使用 Tab 的问题。特别是当它是不同的公司和团队时，他们可能要放弃测试、代码静态检测、代码风格统一等等的一系列问题。</p> <h2 id="微服务化方案-子应用模式"><a href="#微服务化方案-子应用模式" class="header-anchor">#</a> 微服务化方案：子应用模式</h2> <p>除了路由懒加载，我们还可以采用子应用模式，即每个应用都是相互独立地。即我们有一个基座工程，当用户点击相应的路由时，我们去加载这个<strong>独立</strong> 的 Angular 应用；如果是同一个应用下的路由，就不需要重复加载了。而且，这些都可以依赖于浏览器缓存来做。</p> <p>除了路由懒加载，还可以采用的是类似于 Mooa 的应用嵌入方案。如下是基于 Mooa 框架 + Angular 开发而生成的 HTML 示例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;app-root _nghost-c0=&quot;&quot; ng-version=&quot;4.2.0&quot;&gt;
  ...
  &lt;app-home _nghost-c2=&quot;&quot;&gt;
    &lt;app-app1 _nghost-c0=&quot;&quot; ng-version=&quot;5.2.8&quot; style=&quot;display: none;&quot;&gt;&lt;nav _ngcontent-c0=&quot;&quot; class=&quot;navbar&quot;&gt;&lt;/app-app1&gt;
    &lt;iframe frameborder=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;http://localhost:4200/app/help/homeassets/iframe.html&quot; id=&quot;help_206547&quot;&gt;&lt;/iframe&gt;
  &lt;/app-home&gt;
&lt;/app-root&gt;
</code></pre></div><p>Mooa 提供了两种模式，一种是基于 Single-SPA 的实验做的，在同一页面加载、渲染两个 Angular 应用；一种是基于 iFrame 来提供独立的应用容器。</p> <p>解决了以下的问题：</p> <ul><li><strong>首页加载速度更快</strong>，因为只需要加载首页所需要的功能，而不是所有的依赖。</li> <li><strong>多个团队并行开发</strong>，每个团队里可以独立地在自己的项目里开发。</li> <li><strong>独立地进行模块化更新</strong>，现在我们只需要去单独更新我们的应用，而不需要更新整个完整的应用。</li></ul> <p>但是，它仍然包含有以下的问题：</p> <ul><li>重复加载依赖项，即我们在 A 应用中使用到的模块，在 B 应用中也会重新使用到。有一部分可以通过浏览器的缓存来自动解决。</li> <li>第一次打开对应的应用需要时间，当然<strong>预加载</strong>可以解决一部分问题。</li> <li>在非 iframe 模式下运行，会遇到难以预料的第三方依赖冲突。</li></ul> <p>于是在总结了一系列的讨论之后，我们形成了一系列的对比方案：</p> <h2 id="方案对比"><a href="#方案对比" class="header-anchor">#</a> 方案对比</h2> <p>在这个过程中，我们做了大量的方案设计与对比，便想写一篇文章对比一下之前的结果。先看一下图：</p> <p><img src="/assets/img/angular-split-code-compare.92481961.jpg" alt="Angular 代码拆分对比"></p> <p>表格对比：</p> <table><thead><tr><th>x</th> <th>标准 Lazyload</th> <th>构建时集成</th> <th>构建后集成</th> <th>应用独立</th></tr></thead> <tbody><tr><td>开发流程</td> <td>多个团队在同一个代码库里开发</td> <td>多个团队在不同的代码库里开发</td> <td>多个团队在不同的代码库里开发</td> <td>多个团队在不同的代码库里开发</td></tr> <tr><td>构建与发布</td> <td>构建时只需要拿这一份代码去构建、部署</td> <td>将不同代码库的代码整合到一起，再构建应用</td> <td>将直接编译成各个项目模块，运行时通过懒加载合并</td> <td>将直接编译成不同的几个应用，运行时通过主工程加载</td></tr> <tr><td>适用场景</td> <td>单一团队，依赖库少、业务单一</td> <td>多团队，依赖库少、业务单一</td> <td>多团队，依赖库少、业务单一</td> <td>多团队，依赖库多、业务复杂</td></tr> <tr><td>表现方式</td> <td>开发、构建、运行一体</td> <td>开发分离，构建时集成，运行一体</td> <td>开发分离，构建分离，运行一体</td> <td>开发、构建、运行分离</td></tr></tbody></table> <p>详细的介绍如下：</p> <h3 id="标准-lazyload"><a href="#标准-lazyload" class="header-anchor">#</a> 标准 LazyLoad</h3> <p>开发流程：多个团队在同一个代码库里开发，构建时只需要拿这一份代码去部署。</p> <p>行为：开发、构建、运行一体</p> <p>适用场景：单一团队，依赖库少、业务单一</p> <h3 id="lazyload-变体-1-构建时集成"><a href="#lazyload-变体-1-构建时集成" class="header-anchor">#</a> LazyLoad 变体 1：构建时集成</h3> <p>开发流程：多个团队在不同的代码库里开发，在构建时将不同代码库的代码整合到一起，再去构建这个应用。</p> <p>适用场景：多团队，依赖库少、业务单一</p> <p>变体-构建时集成：开发分离，构建时集成，运行一体</p> <h3 id="lazyload-变体-2-构建后集成"><a href="#lazyload-变体-2-构建后集成" class="header-anchor">#</a> LazyLoad 变体 2：构建后集成</h3> <p>开发流程：多个团队在不同的代码库里开发，在构建时将编译成不同的几份代码，运行时会通过懒加载合并到一起。</p> <p>适用场景：多团队，依赖库少、业务单一</p> <p>变体-构建后集成：开发分离，构建分离，运行一体</p> <h3 id="前端微服务化"><a href="#前端微服务化" class="header-anchor">#</a> 前端微服务化</h3> <p>开发流程：多个团队在不同的代码库里开发，在构建时将编译成不同的几个应用，运行时通过主工程加载。</p> <p>适用场景：多团队，依赖库多、业务复杂</p> <p>前端微服务化：开发、构建、运行分离</p> <h2 id="总对比"><a href="#总对比" class="header-anchor">#</a> 总对比</h2> <p>总体的对比如下表所示：</p> <table><thead><tr><th>x</th> <th>标准 Lazyload</th> <th>构建时集成</th> <th>构建后集成</th> <th>应用独立</th></tr></thead> <tbody><tr><td>依赖管理</td> <td>统一管理</td> <td>统一管理</td> <td>统一管理</td> <td>各应用独立管理</td></tr> <tr><td>部署方式</td> <td>统一部署</td> <td>统一部署</td> <td>可单独部署。更新依赖时，需要全量部署</td> <td>可完全独立部署</td></tr> <tr><td>首屏加载</td> <td>依赖在同一个文件，加载速度慢</td> <td>依赖在同一个文件，加载速度慢</td> <td>依赖在同一个文件，加载速度慢</td> <td>依赖各自管理，首页加载快</td></tr> <tr><td>首次加载应用、模块</td> <td>只加载模块，速度快</td> <td>只加载模块，速度快</td> <td>只加载模块，速度快</td> <td>单独加载，加载略慢</td></tr> <tr><td>前期构建成本</td> <td>低</td> <td>设计构建流程</td> <td>设计构建流程</td> <td>设计通讯机制与加载方式</td></tr> <tr><td>维护成本</td> <td>一个代码库不好管理</td> <td>多个代码库不好统一</td> <td>后期需要维护组件依赖</td> <td>后期维护成本低</td></tr> <tr><td>打包优化</td> <td>可进行摇树优化、AoT 编译、删除无用代码</td> <td>可进行摇树优化、AoT 编译、删除无用代码</td> <td>应用依赖的组件无法确定，不能删除无用代码</td> <td>可进行摇树优化、AoT 编译、删除无用代码</td></tr></tbody></table> <h1 id="前端微服务化-使用微前端框架-mooa-开发微前端应用"><a href="#前端微服务化-使用微前端框架-mooa-开发微前端应用" class="header-anchor">#</a> 前端微服务化：使用微前端框架 Mooa 开发微前端应用</h1> <p>Mooa 是一个为 Angular 服务的微前端框架，它是一个基于 <a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noopener noreferrer">single-spa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，针对 IE 10 及 IFRAME 优化的微前端解决方案。</p> <h2 id="mooa-概念"><a href="#mooa-概念" class="header-anchor">#</a> Mooa 概念</h2> <p>Mooa 框架与 Single-SPA 不一样的是，Mooa 采用的是 Master-Slave 架构，即主-从式设计。</p> <p>对于 Web 页面来说，它可以同时存在两个到多个的 Angular 应用：其中的一个 Angular 应用作为主工程存在，剩下的则是子应用模块。</p> <ul><li>主工程，负责加载其它应用，及用户权限管理等核心控制功能。</li> <li>子应用，负责不同模块的具体业务代码。</li></ul> <p>在这种模式下，则由主工程来控制整个系统的行为，子应用则做出一些对应的响应。</p> <h2 id="微前端主工程创建"><a href="#微前端主工程创建" class="header-anchor">#</a> 微前端主工程创建</h2> <p>要创建微前端框架 Mooa 的主工程，并不需要多少修改，只需要使用 <code>angular-cli</code> 来生成相应的应用：</p> <div class="language- extra-class"><pre class="language-text"><code>ng new hello-world
</code></pre></div><p>然后添加 <code>mooa</code> 依赖</p> <div class="language- extra-class"><pre class="language-text"><code>yarn add mooa
</code></pre></div><p>接着创建一个简单的配置文件 <code>apps.json</code>，放在 <code>assets</code> 目录下：</p> <div class="language- extra-class"><pre class="language-text"><code>[{
    &quot;name&quot;: &quot;help&quot;,
    &quot;selector&quot;: &quot;app-help&quot;,
    &quot;baseScriptUrl&quot;: &quot;/assets/help&quot;,
    &quot;styles&quot;: [
      &quot;styles.bundle.css&quot;
    ],
    &quot;prefix&quot;: &quot;help&quot;,
    &quot;scripts&quot;: [
      &quot;inline.bundle.js&quot;,
      &quot;polyfills.bundle.js&quot;,
      &quot;main.bundle.js&quot;
    ]
  }
]]
</code></pre></div><p>接着，在我们的 <code>app.component.ts</code> 中编写相应的创建应用逻辑：</p> <div class="language- extra-class"><pre class="language-text"><code>mooa = new Mooa({
  mode: 'iframe',
  debug: false,
  parentElement: 'app-home',
  urlPrefix: 'app',
  switchMode: 'coexist',
  preload: true,
  includeZone: true
});

constructor(private renderer: Renderer2, http: HttpClient, private router: Router) {
  http.get&lt;IAppOption[]&gt;('/assets/apps.json')
    .subscribe(
      data =&gt; {
        this.createApps(data);
      },
      err =&gt; console.log(err)
    );
}

private createApps(data: IAppOption[]) {
  data.map((config) =&gt; {
    this.mooa.registerApplication(config.name, config, mooaRouter.hashPrefix(config.prefix));
  });

  const that = this;
  this.router.events.subscribe((event) =&gt; {
    if (event instanceof NavigationEnd) {
      that.mooa.reRouter(event);
    }
  });

  return mooa.start();
}
</code></pre></div><p>再为应用创建一个对应的路由即可：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  path: 'app/:appName/:route',
  component: HomeComponent
}
</code></pre></div><p>接着，我们就可以创建 Mooa 子应用。</p> <h2 id="mooa-子应用创建"><a href="#mooa-子应用创建" class="header-anchor">#</a> Mooa 子应用创建</h2> <p>Mooa 官方提供了一个子应用的模块，直接使用该模块即可：</p> <div class="language- extra-class"><pre class="language-text"><code>git clone https://github.com/phodal/mooa-boilerplate
</code></pre></div><p>然后执行：</p> <div class="language- extra-class"><pre class="language-text"><code>npm install
</code></pre></div><p>在安装完依赖后，会进行项目的初始化设置，如更改包名等操作。在这里，将我们的应用取名为 help。</p> <p>然后，我们就可以完成子应用的构建。</p> <p>接着，执行：<code>yarn build</code> 就可以构建出我们的应用。</p> <p>将 <code>dist</code> 目录一下的文件拷贝到主工程的 src/assets/help 目录下，再启动主工程即可。</p> <h2 id="导航到特定的子应用"><a href="#导航到特定的子应用" class="header-anchor">#</a> 导航到特定的子应用</h2> <p>在 Mooa 中，有一个路由接口 <code>mooaPlatform.navigateTo</code>，具体使用情况如下：</p> <div class="language- extra-class"><pre class="language-text"><code>mooaPlatform.navigateTo({
  appName: 'help',
  router: 'home'
});
</code></pre></div><p>它将触发一个 <code>MOOA_EVENT.ROUTING_NAVIGATE</code> 事件。而在我们调用 <code>mooa.start()</code> 方法时，则会开发监听对应的事件：</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener(MOOA_EVENT.ROUTING_NAVIGATE, function(event: CustomEvent) {
  if (event.detail) {
    navigateAppByName(event.detail)
  }
})
</code></pre></div><p>它将负责将应用导向新的应用。</p> <p>嗯，就是这么简单。DEMO 视频如下：</p> <p>Demo 地址见：<a href="http://mooa.phodal.com/" target="_blank" rel="noopener noreferrer">http://mooa.phodal.com/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>GitHub 示例：<a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">https://github.com/phodal/mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="前端微服务化-使用特制的-iframe-微服务化-angular-应用"><a href="#前端微服务化-使用特制的-iframe-微服务化-angular-应用" class="header-anchor">#</a> 前端微服务化：使用特制的 iframe 微服务化 Angular 应用</h1> <p>Angular 基于 Component 的思想，可以让其在一个页面上同时运行多个 Angular 应用；可以在一个 DOM 节点下，存在多个 Angular 应用，即类似于下面的形式：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-home</span> <span class="token attr-name">_nghost-c3</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-help</span> <span class="token attr-name">_nghost-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.2<span class="token punctuation">&quot;</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">_ngcontent-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-help</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-app1</span> <span class="token attr-name">_nghost-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.3<span class="token punctuation">&quot;</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">_ngcontent-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>navbar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-app1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-app2</span> <span class="token attr-name">_nghost-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.2<span class="token punctuation">&quot;</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">_ngcontent-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>navbar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-app2</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-home</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>可这一样一来，难免需要做以下的一些额外的工作：</p> <ul><li>创建子应用项目模板，以统一 Angular 版本</li> <li>构建时，删除子应用的依赖</li> <li>修改第三方模块</li></ul> <p>而在这其中最麻烦的就是<strong>第三方模块</strong>冲突问题。思来想去，在三月中旬，我在 Mooa 中添加了一个 iframe 模式。</p> <h2 id="iframe-微服务架构设计"><a href="#iframe-微服务架构设计" class="header-anchor">#</a> iframe 微服务架构设计</h2> <p>在这里，总的设计思想和之前的《<a href="https://www.phodal.com/blog/how-to-build-a-microfrontend-framework-mooa/" target="_blank" rel="noopener noreferrer">如何解构单体前端应用——前端应用的微服务式拆分<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》中介绍是一致的：</p> <p><img src="/assets/img/mooa-graph.7272c84d.jpg" alt="Mooa 架构"></p> <p>主要过程如下：</p> <ul><li>主工程在运行的时候，会去服务器获取最新的应用配置。</li> <li>主工程在获取到配置后，将一一创建应用，并为应用绑定生命周期。</li> <li>当主工程监测到路由变化的时候，将寻找是否有对应的路由匹配到应用。</li> <li>当匹配对对应应用时，则<strong>创建或显示相应应用的 iframe</strong>，并隐藏其它子应用的 iframe。</li></ul> <p>其加载形式与之前的 Component 模式并没有太大的区别：</p> <p><img src="/assets/img/mooa-app.5053c432.jpg" alt="Mooa Component 加载"></p> <p>而为了控制不同的 iframe 需要做到这么几件事：</p> <ol><li>为不同的子应用分配 ID</li> <li>在子应用中进行 hook，以通知主应用：子应用已加载</li> <li>在子应用中创建对应的事件监听，来响应主应用的 URL 变化事件</li> <li>在主应用中监听子程序的路由跳转等需求</li></ol> <p>因为大部分的代码可以与之前的 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 复用，于是我便在 Mooa 中实现了相应的功能。</p> <h2 id="微前端框架-mooa-的特制-iframe-模式"><a href="#微前端框架-mooa-的特制-iframe-模式" class="header-anchor">#</a> 微前端框架 Mooa 的特制 iframe 模式</h2> <p>iframe 可以创建一个<strong>全新的独立的宿主环境</strong>，这意味着我们的 Angular 应用之间可以相互独立运行，我们唯一要做的是：<strong>建立一个通讯机制</strong>。</p> <p>它可以不修改子应用代码的情况下，可以直接使用。与此同时，它在一般的 iframe 模式进行了优化。使用普通的 iframe 模式，意味着：<strong>我们需要加载大量的重复组件</strong>，即使经过 Tree-Shaking 优化，它也将带来大量的重复内容。如果子应用过多，那么它在初始化应用的时候，体验可能就没有那么友好。但是与此相比，在初始化应用的时候，加载所有的依赖在主程序上，也不是一种很友好的体验。</p> <p>于是，我就在想能不能创建一个更友好地 IFrame 模式，在里面对应用及依赖进行处理。如下，就是最后生成的页面的 iframe 代码：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-home</span> <span class="token attr-name">_nghost-c2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100%<span class="token punctuation">&quot;</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100%<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://localhost:4200/assets/iframe.html<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>help_206547<span class="token punctuation">&quot;</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100%<span class="token punctuation">&quot;</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100%<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://localhost:4200/assets/iframe.html<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id=&quot;app_235458</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-home</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>对，两个 iframe 的 src 是一样的，但是它表现出来的确实是两个不同的 iframe 应用。那个 iframe.html 里面其实是没有内容的：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token name">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>App1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width,initial-scale=1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>icon<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image/x-icon<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>favicon.ico<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>（PS：详细的代码可以见 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">https://github.com/phodal/mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</p> <p>只是为了创建 iframe 的需要而存在的，对于一个 Angular 应用来说，是不是一个 iframe 的区别并不大。但是，对于我们而言，区别就大了。我们可以使用自己的方式来控制这个 IFrame，以及我们所要加载的内容。如：</p> <ul><li>共同 Style Guide 中的 CSS 样式。如，在使用 iframe 集成时，移除不需要的 <link></li> <li>去除不需要重复加载的 JavaScript。如，打包时不需要的 zone.min.js、polyfill.js 等等</li></ul> <p><code>注意</code>：对于一些共用 UI 组件而言，仍然需要重复加载。这也就是 iframe 模式下的问题。</p> <h2 id="微前端框架-mooa-iframe-通讯机制"><a href="#微前端框架-mooa-iframe-通讯机制" class="header-anchor">#</a> 微前端框架 Mooa iframe 通讯机制</h2> <p>为了在主工程与子工程通讯，我们需要做到这么一些事件策略：</p> <h3 id="发布主应用事件"><a href="#发布主应用事件" class="header-anchor">#</a> 发布主应用事件</h3> <p>由于，我们使用 Mooa 来控制 iframe 加载。这就意味着我们可以通过 <code>document.getElementById</code> 来获取到 iframe，随后通过 <code>iframeEl.contentWindow</code> 来发布事件，如下：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> iframeEl<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>iframeId<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>iframeEl <span class="token operator">&amp;&amp;</span> iframeEl<span class="token punctuation">.</span>contentWindow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  iframeEl<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span>option <span class="token operator">=</span> window<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span>option
  iframeEl<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span><span class="token constant">MOOA_EVENT</span><span class="token punctuation">.</span><span class="token constant">ROUTING_CHANGE</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> detail<span class="token operator">:</span> eventArgs <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样，子应用就不需要修改代码，就可以直接接收对应的事件响应。</p> <h3 id="监听子应用事件"><a href="#监听子应用事件" class="header-anchor">#</a> 监听子应用事件</h3> <p>由于，我们也希望能直接在主工程中处理子程序的事件，并且不修改原有的代码。因此，我们也使用同样的方式来在子应用中监听主应用的事件：</p> <div class="language- extra-class"><pre class="language-text"><code>iframeEl.contentWindow.addEventListener(MOOA_EVENT.ROUTING_NAVIGATE, function(event: CustomEvent) {
  if (event.detail) {
    navigateAppByName(event.detail)
  }
})
</code></pre></div><h2 id="示例"><a href="#示例" class="header-anchor">#</a> 示例</h2> <p>同样的我们仍以 Mooa 框架作为示例，我们只需要在创建 mooa 实例时，配置使用 iframe 模式即可：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>mooa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mooa</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'iframe'</span><span class="token punctuation">,</span>
  debug<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  parentElement<span class="token operator">:</span> <span class="token string">'app-home'</span><span class="token punctuation">,</span>
  urlPrefix<span class="token operator">:</span> <span class="token string">'app'</span><span class="token punctuation">,</span>
  switchMode<span class="token operator">:</span> <span class="token string">'coexist'</span><span class="token punctuation">,</span>
  preload<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  includeZone<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">...</span>

that<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span><span class="token function">registerApplicationByLink</span><span class="token punctuation">(</span><span class="token string">'help'</span><span class="token punctuation">,</span> <span class="token string">'/assets/help'</span><span class="token punctuation">,</span> mooaRouter<span class="token punctuation">.</span><span class="token function">matchRoute</span><span class="token punctuation">(</span><span class="token string">'help'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
that<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span><span class="token function">registerApplicationByLink</span><span class="token punctuation">(</span><span class="token string">'app1'</span><span class="token punctuation">,</span> <span class="token string">'/assets/app1'</span><span class="token punctuation">,</span> mooaRouter<span class="token punctuation">.</span><span class="token function">matchRoute</span><span class="token punctuation">(</span><span class="token string">'app1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>mooa<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">...</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>router<span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token keyword">instanceof</span> <span class="token class-name">NavigationEnd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    that<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span><span class="token function">reRouter</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>子程序则直接使用：<a href="https://github.com/phodal/mooa-boilerplate" target="_blank" rel="noopener noreferrer">https://github.com/phodal/mooa-boilerplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就可以了。</p> <h1 id="资源"><a href="#资源" class="header-anchor">#</a> 资源</h1> <p>相关资料：</p> <ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/%E5%BD%B1%E5%AD%90_DOM" target="_blank" rel="noopener noreferrer">MDN 影子DOM（Shadow DOM）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="noopener noreferrer">Web Components<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developers.google.com/web/fundamentals/web-components/shadowdom?hl=zh-cn" target="_blank" rel="noopener noreferrer">Shadow DOM v1：独立的网络组件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h1 id="thinking-in-microfrontend-微前端的那些事儿"><a href="#thinking-in-microfrontend-微前端的那些事儿" class="header-anchor">#</a> Thinking in Microfrontend (微前端的那些事儿)</h1> <p><a href="/design/microserviceWeb/english.html">English</a></p> <blockquote><p>微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为<strong>多个小型前端应用聚合为一的应用</strong>。各个前端应用还可以<strong>独立运行</strong>、<strong>独立开发</strong>、<strong>独立部署</strong>。</p></blockquote> <p>同时，它们也可以在<strong>共享组件</strong>的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。</p> <p><strong>注意</strong>：这里的前端应用指的是前后端分离的单页面应用，在这基础才谈论微前端才有意义。</p> <p>支持作者（纸质版）：</p> <p><img src="/assets/img/9787121365348.21476dce.jpg" alt="前端架构：从入门到微前端"></p> <p>支持作者：</p> <ul><li>京东：《<a href="https://item.jd.com/12621088.html" target="_blank" rel="noopener noreferrer">前端架构：从入门到微前端<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》</li></ul> <p><strong>目录</strong></p> <ul><li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF">微前端的那些事儿</a></li> <li><a href="#%E5%AE%9E%E6%96%BD%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F">实施微前端的六种方式</a> <ul><li><a href="#%E5%9F%BA%E7%A1%80%E9%93%BA%E5%9E%AB%E5%BA%94%E7%94%A8%E5%88%86%E5%8F%91%E8%B7%AF%E7%94%B1---%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91%E5%BA%94%E7%94%A8">基础铺垫：应用分发路由 -&gt;
路由分发应用</a> <ul><li><a href="#%E5%90%8E%E7%AB%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8---%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8">后端：函数调用 -&gt; 远程调用</a></li> <li><a href="#%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8---%E5%BA%94%E7%94%A8%E8%B0%83%E7%94%A8">前端：组件调用 -&gt; 应用调用</a></li></ul></li> <li><a href="#%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91%E5%BC%8F%E5%BE%AE%E5%89%8D%E7%AB%AF">路由分发式微前端</a></li> <li><a href="#%E4%BD%BF%E7%94%A8-iframe-%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8">使用 iFrame 创建容器</a></li> <li><a href="#%E8%87%AA%E5%88%B6%E6%A1%86%E6%9E%B6%E5%85%BC%E5%AE%B9%E5%BA%94%E7%94%A8">自制框架兼容应用</a></li> <li><a href="#%E7%BB%84%E5%90%88%E5%BC%8F%E9%9B%86%E6%88%90%E5%B0%86%E5%BA%94%E7%94%A8%E5%BE%AE%E4%BB%B6%E5%8C%96">组合式集成：将应用微件化</a></li> <li><a href="#%E7%BA%AF-web-components-%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA">纯 Web Components 技术构建</a></li> <li><a href="#%E7%BB%93%E5%90%88-web-components-%E6%9E%84%E5%BB%BA">结合 Web Components 构建</a> <ul><li><a href="#%E5%9C%A8-web-components-%E4%B8%AD%E9%9B%86%E6%88%90%E7%8E%B0%E6%9C%89%E6%A1%86%E6%9E%B6">在 Web Components
中集成现有框架</a></li> <li><a href="#%E9%9B%86%E6%88%90%E5%9C%A8%E7%8E%B0%E6%9C%89%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84-web-components">集成在现有框架中的 Web
Components</a></li></ul></li> <li><a href="#%E5%A4%8D%E5%90%88%E5%9E%8B">复合型</a></li></ul></li> <li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%BC%80%E5%A7%8B%E5%9C%A8%E6%B5%81%E8%A1%8Cweb-%E5%BA%94%E7%94%A8%E7%9A%84%E8%81%9A%E5%90%88">为什么微前端开始在流行------Web
应用的聚合</a> <ul><li><a href="#%E5%89%8D%E7%AB%AF%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB">前端遗留系统迁移</a></li> <li><a href="#%E5%90%8E%E7%AB%AF%E8%A7%A3%E8%80%A6%E5%89%8D%E7%AB%AF%E8%81%9A%E5%90%88">后端解耦，前端聚合</a></li> <li><a href="#%E5%85%BC%E5%AE%B9%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F">兼容遗留系统</a></li></ul></li> <li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%84%E5%8D%95%E4%BD%93%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%8F%E6%8B%86%E5%88%86">如何解构单体前端应用------前端应用的微服务式拆分</a> <ul><li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8C%96">前端微服化</a> <ul><li><a href="#%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91">独立开发</a></li> <li><a href="#%E7%8B%AC%E7%AB%8B%E9%83%A8%E7%BD%B2">独立部署</a></li> <li><a href="#%E6%88%91%E4%BB%AC%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%8A%80%E6%9C%AF%E6%97%A0%E5%85%B3%E5%90%97">我们真的需要技术无关吗？</a></li> <li><a href="#%E4%B8%8D%E5%BD%B1%E5%93%8D%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C">不影响用户体验</a></li></ul></li> <li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5">微前端的设计理念</a> <ul><li><a href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%80%E4%B8%AD%E5%BF%83%E5%8C%96%E8%B7%AF%E7%94%B1">设计理念一：中心化路由</a></li> <li><a href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%BA%8C%E6%A0%87%E8%AF%86%E5%8C%96%E5%BA%94%E7%94%A8">设计理念二：标识化应用</a></li> <li><a href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">设计理念三：生命周期</a></li> <li><a href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%9B%9B%E7%8B%AC%E7%AB%8B%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96">设计理念四：独立部署与配置自动化</a></li></ul></li> <li><a href="#%E5%AE%9E%E6%88%98%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">实战微前端架构设计</a> <ul><li><a href="#%E7%8B%AC%E7%AB%8B%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96">独立部署与配置自动化</a></li> <li><a href="#%E5%BA%94%E7%94%A8%E9%97%B4%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6">应用间路由------事件</a></li></ul></li></ul></li> <li><a href="#%E5%A4%A7%E5%9E%8B-angular-%E5%BA%94%E7%94%A8%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5">大型 Angular
应用微前端的四种拆分策略</a> <ul><li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93">前端微服务化：路由懒加载及其变体</a></li> <li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%96%B9%E6%A1%88%E5%AD%90%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F">微服务化方案：子应用模式</a></li> <li><a href="#%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">方案对比</a> <ul><li><a href="#%E6%A0%87%E5%87%86-lazyload">标准 LazyLoad</a></li> <li><a href="#lazyload-%E5%8F%98%E4%BD%93-1%E6%9E%84%E5%BB%BA%E6%97%B6%E9%9B%86%E6%88%90">LazyLoad 变体 1：构建时集成</a></li> <li><a href="#lazyload-%E5%8F%98%E4%BD%93-2%E6%9E%84%E5%BB%BA%E5%90%8E%E9%9B%86%E6%88%90">LazyLoad 变体 2：构建后集成</a></li> <li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96">前端微服务化</a></li></ul></li> <li><a href="#%E6%80%BB%E5%AF%B9%E6%AF%94">总对比</a></li></ul></li> <li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E4%BD%BF%E7%94%A8%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-mooa-%E5%BC%80%E5%8F%91%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8">前端微服务化：使用微前端框架 Mooa
开发微前端应用</a> <ul><li><a href="#mooa-%E6%A6%82%E5%BF%B5">Mooa 概念</a></li> <li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%BB%E5%B7%A5%E7%A8%8B%E5%88%9B%E5%BB%BA">微前端主工程创建</a></li> <li><a href="#mooa-%E5%AD%90%E5%BA%94%E7%94%A8%E5%88%9B%E5%BB%BA">Mooa 子应用创建</a></li> <li><a href="#%E5%AF%BC%E8%88%AA%E5%88%B0%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AD%90%E5%BA%94%E7%94%A8">导航到特定的子应用</a></li></ul></li> <li><a href="#%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E4%BD%BF%E7%94%A8%E7%89%B9%E5%88%B6%E7%9A%84-iframe-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96-angular-%E5%BA%94%E7%94%A8">前端微服务化：使用特制的 iframe 微服务化 Angular
应用</a> <ul><li><a href="#iframe-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">iframe 微服务架构设计</a></li> <li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-mooa-%E7%9A%84%E7%89%B9%E5%88%B6-iframe-%E6%A8%A1%E5%BC%8F">微前端框架 Mooa 的特制 iframe
模式</a></li> <li><a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-mooa-iframe-%E9%80%9A%E8%AE%AF%E6%9C%BA%E5%88%B6">微前端框架 Mooa iframe
通讯机制</a> <ul><li><a href="#%E5%8F%91%E5%B8%83%E4%B8%BB%E5%BA%94%E7%94%A8%E4%BA%8B%E4%BB%B6">发布主应用事件</a></li> <li><a href="#%E7%9B%91%E5%90%AC%E5%AD%90%E5%BA%94%E7%94%A8%E4%BA%8B%E4%BB%B6">监听子应用事件</a></li></ul></li> <li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li></ul></li> <li><a href="#%E8%B5%84%E6%BA%90">资源</a></li></ul> <h1 id="为什么微前端开始在流行-web-应用的聚合-2"><a href="#为什么微前端开始在流行-web-应用的聚合-2" class="header-anchor">#</a> 为什么微前端开始在流行——Web 应用的聚合</h1> <blockquote><p>采用新技术，更多不是因为先进，而是因为它能解决痛点。</p></blockquote> <p>过去，我一直有一个疑惑，人们是否真的需要微服务，是否真的需要微前端。毕竟，没有银弹。当人们考虑是否采用一种新的架构，除了考虑它带来好处之外，仍然也考量着存在的大量的风险和技术挑战。</p> <h2 id="前端遗留系统迁移-2"><a href="#前端遗留系统迁移-2" class="header-anchor">#</a> 前端遗留系统迁移</h2> <p>自微前端框架 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 及对应的《<a href="https://github.com/phodal/microfrontend" target="_blank" rel="noopener noreferrer">微前端的那些事儿<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》发布的两个多月以来，我陆陆续续地接收到一些微前端架构的一些咨询。过程中，我发现了一件很有趣的事：<strong>解决遗留系统，才是人们采用微前端方案最重要的原因</strong>。</p> <p>这些咨询里，开发人员所遇到的情况，与我之前遇到的情形并相似，我的场景是：设计一个新的前端架构。他们开始考虑前端微服务化，是因为遗留系统的存在。</p> <p>过去那些使用 Backbone.js、Angular.js、Vue.js 1 等等框架所编写的单页面应用，已经在线上稳定地运行着，也没有新的功能。对于这样的应用来说，我们也没有理由浪费时间和精力重写旧的应用。这里的那些使用旧的、不再使用的技术栈编写的应用，可以称为遗留系统。而，这些应用又需要结合到新应用中使用。我遇到的较多的情况是：旧的应用使用的是 Angular.js 编写，而新的应用开始采用 Angular 2+。这对于业务稳定的团队来说，是极为常见的技术栈。</p> <p>在即不重写原有系统的基础之下，又可以抽出人力来开发新的业务。其不仅仅对于业务人员来说， 是一个相当吸引力的特性；对于技术人员来说，不重写旧的业务，同时还能做一些技术上的挑战，也是一件相当有挑战的事情。</p> <h2 id="后端解耦-前端聚合-2"><a href="#后端解耦-前端聚合-2" class="header-anchor">#</a> 后端解耦，前端聚合</h2> <p>而前端微服务的一个卖点也在这里，去兼容不同类型的前端框架。这让我又联想到微服务的好处，及许多项目落地微服务的原因：</p> <p>在初期，后台微服务的一个很大的卖点在于，可以使用不同的技术栈来开发后台应用。但是，事实上，采用微服务架构的组织和机构，一般都是中大型规模的。相较于中小型，对于框架和语言的选型要求比较严格，如在内部限定了框架，限制了语言。因此，在充分使用不同的技术栈来发挥微服务的优势这一点上，几乎是很少出现的。在这些大型组织机构里，采用微服务的原因主要还是在于，<strong>使用微服务架构来解耦服务间依赖</strong>。</p> <p>而在前端微服务化上，则是恰恰与之相反的，人们更想要的结果是<strong>聚合</strong>，尤其是那些 To B（to Bussiness）的应用。</p> <p>在这两三年里，移动应用出现了一种趋势，用户不想装那么多应用了。而往往一家大的商业公司，会提供一系列的应用。这些应用也从某种程度上，反应了这家公司的组织架构。然而，在用户的眼里他们就是一家公司，他们就只应该有一个产品。相似的，这种趋势也在桌面 Web 出现。<strong>聚合</strong>成为了一个技术趋势，体现在前端的聚合就是微服务化架构。</p> <h2 id="兼容遗留系统-2"><a href="#兼容遗留系统-2" class="header-anchor">#</a> 兼容遗留系统</h2> <p>那么，在这个时候，我们就需要使用新的技术、新的架构，来容纳、兼容这些旧的应用。而前端微服务化，正好是契合人们想要的这个卖点罢了。</p> <h1 id="实施微前端的六种方式-2"><a href="#实施微前端的六种方式-2" class="header-anchor">#</a> 实施微前端的六种方式</h1> <p>微前端架构是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为<strong>多个小型前端应用聚合为一的应用</strong>。</p> <p>由此带来的变化是，这些前端应用可以<strong>独立运行</strong>、<strong>独立开发</strong>、<strong>独立部署</strong>。以及，它们应该可以在<strong>共享组件</strong>的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。</p> <p><strong>注意</strong>：这里的前端应用指的是前后端分离的单应用页面，在这基础才谈论微前端才有意义。</p> <p>结合我最近半年在<a href="https://github.com/phodal/microfrontends" target="_blank" rel="noopener noreferrer">微前端<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>方面的实践和研究来看，微前端架构一般可以由以下几种方式进行：</p> <ol><li>使用 HTTP 服务器的路由来重定向多个应用</li> <li>在不同的框架之上设计通讯、加载机制，诸如 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noopener noreferrer">Single-SPA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>通过组合多个独立应用、组件来构建一个单体应用</li> <li>iFrame。使用 iFrame 及自定义消息传递机制</li> <li>使用纯 Web Components 构建应用</li> <li>结合 Web Components 构建</li></ol> <h2 id="基础铺垫-应用分发路由-路由分发应用-2"><a href="#基础铺垫-应用分发路由-路由分发应用-2" class="header-anchor">#</a> 基础铺垫：应用分发路由 -&gt; 路由分发应用</h2> <p>在一个单体前端、单体后端应用中，有一个典型的特征，即路由是由<strong>框架</strong>来分发的，框架将路由指定到对应的组件或者内部服务中。微服务在这个过程中做的事情是，将调用由<strong>函数调用</strong>变成了<strong>远程调用</strong>，诸如远程 HTTP 调用。而微前端呢，也是类似的，它是将<strong>应用内的组件调用</strong>变成了更细粒度的<strong>应用间组件调用</strong>，即原先我们只是将路由分发到应用的组件执行，现在则需要根据路由来找到对应的应用，再由应用分发到对应的组件上。</p> <h3 id="后端-函数调用-远程调用-2"><a href="#后端-函数调用-远程调用-2" class="header-anchor">#</a> 后端：函数调用 -&gt; 远程调用</h3> <p>在大多数的 CRUD 类型的 Web 应用中，也都存在一些极为相似的模式，即：首页 -&gt; 列表 -&gt; 详情：</p> <ul><li>首页，用于面向用户展示特定的数据或页面。这些数据通常是有限个数的，并且是多种模型的。</li> <li>列表，即数据模型的聚合，其典型特点是某一类数据的集合，可以看到尽可能多的<strong>数据概要</strong>（如 Google 只返回  100 页），典型见 Google、淘宝、京东的搜索结果页。</li> <li>详情，展示一个数据的尽可能多的内容。</li></ul> <p>如下是一个 Spring 框架，用于返回首页的示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">homePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token string">&quot;/WEB-INF/jsp/index.jsp&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于某个详情页面来说，它可能是这样的：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;/detail/{detailId}&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">detail</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ModelMap</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token string">&quot;/WEB-INF/jsp/detail.jsp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;detail&quot;</span><span class="token punctuation">,</span> detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么，在微服务的情况下，它则会变成这样子：</p> <div class="language- extra-class"><pre class="language-text"><code>@RequestMapping(&quot;/name&quot;)
public String name(){
    String name = restTemplate.getForObject(&quot;http://account/name&quot;, String.class);
    return Name&quot; + name;
}
</code></pre></div><p>而后端在这个过程中，多了一个服务发现的服务，来管理不同微服务的关系。</p> <h3 id="前端-组件调用-应用调用-2"><a href="#前端-组件调用-应用调用-2" class="header-anchor">#</a> 前端：组件调用 -&gt; 应用调用</h3> <p>在形式上来说，单体前端框架的路由和单体后端应用，并没有太大的区别：<strong>依据不同的路由，来返回不同页面的模板。</strong></p> <div class="language-javascritp extra-class"><pre class="language-text"><code>const appRoutes: Routes = [
  { path: 'index', component: IndexComponent },
  { path: 'detail/:id', component: DetailComponent },
];
</code></pre></div><p>而当我们将之微服务化后，则可能变成应用 A 的路由：</p> <div class="language-javascritp extra-class"><pre class="language-text"><code>const appRoutes: Routes = [
  { path: 'index', component: IndexComponent },
];
</code></pre></div><p>外加之应用 B 的路由：</p> <div class="language-javascritp extra-class"><pre class="language-text"><code>const appRoutes: Routes = [
  { path: 'detail/:id', component: DetailComponent },
];
</code></pre></div><p>而问题的关键就在于：<strong>怎么将路由分发到这些不同的应用中去</strong>。与此同时，还要负责管理不同的前端应用。</p> <h2 id="路由分发式微前端-2"><a href="#路由分发式微前端-2" class="header-anchor">#</a> 路由分发式微前端</h2> <p><strong>路由分发式微前端</strong>，即通过路由将不同的业务<strong>分发到不同的、独立前端应用</strong>上。其通常可以通过 HTTP 服务器的反向代理来实现，又或者是应用框架自带的路由来解决。</p> <p>就当前而言，通过路由分发式的微前端架构应该是采用最多、最易采用的 “微前端” 方案。但是这种方式看上去更像是<strong>多个前端应用的聚合</strong>，即我们只是将这些不同的前端应用拼凑到一起，使他们看起来像是一个完整的整体。但是它们并不是，每次用户从 A 应用到 B 应用的时候，往往需要刷新一下页面。</p> <p>在几年前的一个项目里，我们当时正在进行<strong>遗留系统重写</strong>。我们制定了一个迁移计划：</p> <ol><li>首先，使用<strong>静态网站生成</strong>动态生成首页</li> <li>其次，使用 React 计划栈重构详情页</li> <li>最后，替换搜索结果页</li></ol> <p>整个系统并不是一次性迁移过去，而是一步步往下进行。因此在完成不同的步骤时，我们就需要上线这个功能，于是就需要使用 Nginx 来进行路由分发。</p> <p>如下是一个基于路由分发的 Nginx 配置示例：</p> <div class="language- extra-class"><pre class="language-text"><code>http {
  server {
    listen       80;
    server_name  www.phodal.com;
    location /api/ {
      proxy_pass http://http://172.31.25.15:8000/api;
    }
    location /web/admin {
      proxy_pass http://172.31.25.29/web/admin;
    }
    location /web/notifications {
      proxy_pass http://172.31.25.27/web/notifications;
    }
    location / {
      proxy_pass /;
    }
  }
}
</code></pre></div><p>在这个示例里，不同的页面的请求被分发到不同的服务器上。</p> <p>随后，我们在别的项目上也使用了类似的方式，其主要原因是：<strong>跨团队的协作</strong>。当团队达到一定规模的时候，我们不得不面对这个问题。除此，还有 Angluar 跳崖式升级的问题。于是，在这种情况下，用户前台使用 Angular 重写，后台继续使用 Angular.js 等保持再有的技术栈。在不同的场景下，都有一些相似的技术决策。</p> <p>因此在这种情况下，它适用于以下场景：</p> <ul><li>不同技术栈之间差异比较大，难以兼容、迁移、改造</li> <li>项目不想花费大量的时间在这个系统的改造上</li> <li>现有的系统在未来将会被取代</li> <li>系统功能已经很完善，基本不会有新需求</li></ul> <p>而在满足上面场景的情况下，如果为了更好的用户体验，还可以采用 iframe 的方式来解决。</p> <h2 id="使用-iframe-创建容器-2"><a href="#使用-iframe-创建容器-2" class="header-anchor">#</a> 使用 iFrame 创建容器</h2> <p>iFrame 作为一个非常古老的，人人都觉得普通的技术，却一直很管用。</p> <blockquote><p><strong>HTML 内联框架元素</strong> <code>&lt;iframe&gt;</code> 表示嵌套的正在浏览的上下文，能有效地将另一个 HTML 页面嵌入到当前页面中。</p></blockquote> <p>iframe 可以创建一个全新的独立的宿主环境，这意味着我们的前端应用之间可以相互独立运行。采用 iframe 有几个重要的前提：</p> <ul><li>网站不需要 SEO 支持</li> <li>拥有相应的<strong>应用管理机制</strong>。</li></ul> <p>如果我们做的是一个应用平台，会在我们的系统中集成第三方系统，或者多个不同部门团队下的系统，显然这是一个不错的方案。一些典型的场景，如传统的 Desktop 应用迁移到 Web 应用：</p> <p><img src="/assets/img/angular-tabs-example.65ab370b.png" alt="Angular Tabs 示例"></p> <p>如果这一类应用过于复杂，那么它必然是要进行微服务化的拆分。因此，在采用 iframe 的时候，我们需要做这么两件事：</p> <ul><li>设计<strong>管理应用机制</strong></li> <li>设计<strong>应用通讯机制</strong></li></ul> <p><strong>加载机制</strong>。在什么情况下，我们会去加载、卸载这些应用；在这个过程中，采用怎样的动画过渡，让用户看起来更加自然。</p> <p><strong>通讯机制</strong>。直接在每个应用中创建 <code>postMessage</code> 事件并监听，并不是一个友好的事情。其本身对于应用的侵入性太强，因此通过 <code>iframeEl.contentWindow</code> 去获取 iFrame 元素的 Window 对象是一个更简化的做法。随后，就需要<strong>定义一套通讯规范</strong>：事件名采用什么格式、什么时候开始监听事件等等。</p> <p>有兴趣的读者，可以看看笔者之前写的微前端框架：<a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>不管怎样，iframe 对于我们今年的 KPI 怕是带不来一丝的好处，那么我们就去造个轮子吧。</p> <h2 id="自制框架兼容应用-2"><a href="#自制框架兼容应用-2" class="header-anchor">#</a> 自制框架兼容应用</h2> <p>不论是基于 Web Components 的 Angular，或者是 VirtualDOM 的 React 等，现有的前端框架都离不开基本的 HTML 元素 DOM。</p> <p>那么，我们只需要：</p> <ol><li>在页面合适的地方引入或者创建 DOM</li> <li>用户操作时，加载对应的应用（触发应用的启动），并能卸载应用。</li></ol> <p>第一个问题，创建 DOM 是一个容易解决的问题。而第二个问题，则一点儿不容易，特别是移除 DOM 和相应应用的监听。当我们拥有一个不同的技术栈时，我们就需要有针对性设计出一套这样的逻辑。</p> <p>尽管 <a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noopener noreferrer">Single-SPA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 已经拥有了大部分框架（如 React、Angular、Vue 等框架）的启动和卸载处理，但是它仍然不是适合于生产用途。当我基于 Single-SPA 为 Angular 框架设计一个微前端架构的应用时，我最后选择重写一个自己的框架，即 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>虽然，这种方式的上手难度相对比较高，但是后期订制及可维护性比较方便。在不考虑每次加载应用带来的用户体验问题，其唯一存在的风险可能是：<strong>第三方库不兼容</strong>。</p> <p>但是，不论怎样，与 iFrame 相比，其在技术上更具有<strong>可吹牛逼性</strong>，更有看点。同样的，与 iframe 类似，我们仍然面对着一系列的不大不小的问题：</p> <ul><li>需要设计一套管理应用的机制。</li> <li>对于流量大的 toC 应用来说，会在首次加载的时候，会多出大量的请求</li></ul> <p>而我们即又要拆分应用，又想 blabla……，我们还能怎么做？</p> <h2 id="组合式集成-将应用微件化-2"><a href="#组合式集成-将应用微件化-2" class="header-anchor">#</a> 组合式集成：将应用微件化</h2> <p><strong>组合式集成</strong>，即通过<strong>软件工程</strong>的方式在构建前、构建时、构建后等步骤中，对应用进行一步的拆分，并重新组合。</p> <p>从这种定义上来看，它可能算不上并不是一种微前端——它可以满足了微前端的三个要素，即：<strong>独立运行</strong>、<strong>独立开发</strong>、<strong>独立部署</strong>。但是，配合上前端框架的组件 Lazyload 功能——即在需要的时候，才加载对应的业务组件或应用，它看上去就是一个微前端应用。</p> <p>与此同时，由于所有的依赖、Pollyfill 已经尽可能地在首次加载了，CSS 样式也不需要重复加载。</p> <p>常见的方式有：</p> <ul><li>独立构建组件和应用，生成 chunk 文件，构建后再<strong>归类</strong>生成的 chunk 文件。（这种方式更类似于微服务，但是成本更高）</li> <li>开发时独立开发组件或应用，集成时合并组件和应用，最后生成单体的应用。</li> <li>在运行时，加载应用的 Runtime，随后加载对应的应用代码和模板。</li></ul> <p>应用间的关系如下图所示（其忽略图中的 “前端微服务化”）：</p> <p><img src="/assets/img/angular-split-code-compare.92481961.jpg" alt="组合式集成对比"></p> <p>这种方式看上去相当的理想，即能满足多个团队并行开发，又能构建出适合的交付物。</p> <p>但是，首先它有一个严重的限制：<strong>必须使用同一个框架</strong>。对于多数团队来说，这并不是问题。采用微服务的团队里，也不会因为微服务这一个前端，来使用不同的语言和技术来开发。当然了，如果要使用别的框架，也不是问题，我们只需要结合上一步中的<strong>自制框架兼容应用</strong>就可以满足我们的需求。</p> <p>其次，采用这种方式还有一个限制，那就是：<strong>规范！****规范！****规范！</strong>。在采用这种方案时，我们需要：</p> <ul><li>统一依赖。统一这些依赖的版本，引入新的依赖时都需要一一加入。</li> <li>规范应用的组件及路由。避免不同的应用之间，因为这些组件名称发生冲突。</li> <li>构建复杂。在有些方案里，我们需要修改构建系统，有些方案里则需要复杂的架构脚本。</li> <li>共享通用代码。这显然是一个要经常面对的问题。</li> <li>制定代码规范。</li></ul> <p>因此，这种方式看起来更像是一个软件工程问题。</p> <p>现在，我们已经有了四种方案，每个方案都有自己的利弊。显然，结合起来会是一种更理想的做法。</p> <p>考虑到现有及常用的技术的局限性问题，让我们再次将目光放得长远一些。</p> <h2 id="纯-web-components-技术构建-2"><a href="#纯-web-components-技术构建-2" class="header-anchor">#</a> 纯 Web Components 技术构建</h2> <p>在学习 Web Components 开发微前端架构的过程中，我尝试去写了我自己的 Web Components 框架：<a href="https://github.com/phodal/oan" target="_blank" rel="noopener noreferrer">oan<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。在添加了一些基本的 Web 前端框架的功能之后，我发现这项技术特别适合于<strong>作为微前端的基石</strong>。</p> <blockquote><p>Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 Web 应用中使用它们。</p></blockquote> <p>它主要由四项技术组件：</p> <ul><li>Custom elements，允许开发者创建自定义的元素，诸如 <today-news></today-news>。</li> <li>Shadow DOM，即影子 DOM，通常是将 Shadow DOM 附加到主文档 DOM 中，并可以控制其关联的功能。而这个 Shadow DOM 则是不能直接用其它主文档 DOM 来控制的。</li> <li>HTML templates，即 <code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素，用于编写不在页面中显示的标记模板。</li> <li>HTML Imports，用于引入自定义组件。</li></ul> <p>每个组件由 <code>link</code> 标签引入：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;link rel=&quot;import&quot; href=&quot;components/di-li.html&quot;&gt;
&lt;link rel=&quot;import&quot; href=&quot;components/d-header.html&quot;&gt;
</code></pre></div><p>随后，在各自的 HTML 文件里，创建相应的组件元素，编写相应的组件逻辑。一个典型的 Web Components 应用架构如下图所示：</p> <p><img src="/assets/img/web-components-architecture.a9eeefba.png" alt="Web Components 架构"></p> <p>可以看到这边方式与我们上面使用 iframe 的方式很相似，组件拥有自己独立的 <code>Scripts</code> 和 <code>Styles</code>，以及对应的用于单独部署组件的域名。然而它并没有想象中的那么美好，要直接使用<strong>纯</strong> Web Components 来构建前端应用的难度有：</p> <ul><li>重写现有的前端应用。是的，现在我们需要完成使用 Web Components 来完成整个系统的功能。</li> <li>上下游生态系统不完善。缺乏相应的一些第三方控件支持，这也是为什么 jQuery 相当流行的原因。</li> <li>系统架构复杂。当应用被拆分为一个又一个的组件时，组件间的通讯就成了一个特别大的麻烦。</li></ul> <p>Web Components 中的 ShadowDOM 更像是新一代的前端 DOM 容器。而遗憾的是并不是所有的浏览器，都可以完全支持 Web Components。</p> <h2 id="结合-web-components-构建-2"><a href="#结合-web-components-构建-2" class="header-anchor">#</a> 结合 Web Components 构建</h2> <p>Web Components 离现在的我们太远，可是结合 Web Components 来构建前端应用，则更是一种面向未来演进的架构。或者说在未来的时候，我们可以开始采用这种方式来构建我们的应用。好在，已经有框架在打造这种可能性。</p> <p>就当前而言，有两种方式可以结合 Web Components 来构建微前端应用：</p> <ul><li>使用 Web Components 构建独立于框架的组件，随后在对应的框架中引入这些组件</li> <li>在 Web Components 中引入现有的框架，类似于 iframe 的形式</li></ul> <p>前者是一种组件式的方式，或者则像是在迁移未来的 “遗留系统” 到未来的架构上。</p> <h3 id="在-web-components-中集成现有框架-2"><a href="#在-web-components-中集成现有框架-2" class="header-anchor">#</a> 在 Web Components 中集成现有框架</h3> <p>现有的 Web 框架已经有一些可以支持 Web Components 的形式，诸如 Angular 支持的 createCustomElement，就可以实现一个 Web Components 形式的组件：</p> <div class="language- extra-class"><pre class="language-text"><code>platformBrowser()
  .bootstrapModuleFactory(MyPopupModuleNgFactory)
    .then(({injector}) =&gt; {
      const MyPopupElement = createCustomElement(MyPopup, {injector});
      customElements.define(‘my-popup’, MyPopupElement);
});
</code></pre></div><p>在未来，将有更多的框架可以使用类似这样的形式，集成到 Web Components 应用中。</p> <h3 id="集成在现有框架中的-web-components-2"><a href="#集成在现有框架中的-web-components-2" class="header-anchor">#</a> 集成在现有框架中的 Web Components</h3> <p>另外一种方式，则是类似于 <a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener noreferrer">Stencil<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的形式，将组件直接构建成 Web Components 形式的组件，随后在对应的诸如，如 React 或者 Angular 中直接引用。</p> <p>如下是一个在 React 中引用 Stencil 生成的 Web Components 的例子：</p> <div class="language-javascriptA extra-class"><pre class="language-text"><code>import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

import 'test-components/testcomponents';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
registerServiceWorker();
</code></pre></div><p>在这种情况之下，我们就可以构建出独立于框架的组件。</p> <p>同样的 Stencil 仍然也只是支持最近的一些浏览器，比如：Chrome、Safari、Firefox、Edge 和 IE11</p> <h2 id="复合型-2"><a href="#复合型-2" class="header-anchor">#</a> 复合型</h2> <p><strong>复合型</strong>，对就是上面的几个类别中，随便挑几种组合到一起。</p> <p>我就不废话了~~。</p> <h1 id="微前端架构选型指南-2"><a href="#微前端架构选型指南-2" class="header-anchor">#</a> 微前端架构选型指南</h1> <p>在上一节《实施前端微服务化的六七种方式》中，介绍了在实施微前端的过程中，我们采用的一些不同方案的架构方案。在这篇文章中，我将总结如何依据不同的情况来选择合适的方案。</p> <h2 id="快速选型指南图-2"><a href="#快速选型指南图-2" class="header-anchor">#</a> 快速选型指南图</h2> <p>我还是直接先给结论：</p> <p><img src="/assets/img/choice-your-microservices.8a002c9b.png" alt="微前端选型指南"></p> <p>关键点的相关解释如下：</p> <p><strong>框架限制</strong>。在后台微服务系统里，人们使用其它语言的库来开发新的服务，如用于人工智能的 Python。但是在前端，几乎不存在这种可能性。所以当我们的前端框架只有一个时，我们在采用微前端的技术时，可选范围就更大了。而遗憾的是，多数组织需要兼容遗留系统。</p> <p><strong>IE 问题</strong>。不论是在几年前，还是在今年，我们实施微前端最先考虑的就是对于 IE 的支持。在我遇到的项目上，基本上都需要支持 IE，因此在技术选型上就受限一定的限制。而在我们那些不需要支持 IE 的项目上，他们就可以使用 WebComponents 技术来构建微前端应用。</p> <p><strong>依赖独立</strong>。即各个微前端应用的依赖是要统一管理，还是要在各个应该中自己管理。统一管理可以解决重复加载依赖的问题，独立管理会带来额外的流量开销和等待时间。</p> <h2 id="微前端方案的对比-简要对比-2"><a href="#微前端方案的对比-简要对比-2" class="header-anchor">#</a> 微前端方案的对比：简要对比</h2> <p>如果你对上述的几个方面，仍然不是很熟悉的话，请阅读《实施前端微服务化的六七种方式》。</p> <table><thead><tr><th>方式</th> <th>开发成本</th> <th>维护成本</th> <th>可行性</th> <th>同一框架要求</th> <th>实现难度</th> <th>潜在风险</th></tr></thead> <tbody><tr><td>路由分发</td> <td>低</td> <td>低</td> <td>高</td> <td>否</td> <td>★</td> <td>这个方案太普通了</td></tr> <tr><td>iFrame</td> <td>低</td> <td>低</td> <td>高</td> <td>否</td> <td>★</td> <td>这个方案太普通了</td></tr> <tr><td>应用微服务化</td> <td>高</td> <td>低</td> <td>中</td> <td>否</td> <td>★★★★</td> <td>针对每个框架做定制及 Hook</td></tr> <tr><td>微件化</td> <td>高</td> <td>中</td> <td>低</td> <td>是</td> <td>★★★★★</td> <td>针对构建系统，如 webpack 进行 hack</td></tr> <tr><td>微应用化</td> <td>中</td> <td>中</td> <td>高</td> <td>是</td> <td>★★★</td> <td>统一不同应用的构建规范</td></tr> <tr><td>纯 Web Components</td> <td>高</td> <td>低</td> <td>高</td> <td>否</td> <td>★★</td> <td>新技术，浏览器的兼容问题</td></tr> <tr><td>结合 Web Components</td> <td>高</td> <td>低</td> <td>高</td> <td>否</td> <td>★★</td> <td>新技术，浏览器的兼容问题</td></tr></tbody></table> <p>同样的，一些复杂概念的解释如下：</p> <p><strong>应用微服务化</strong>，即每个前端应用一个独立的服务化前端应用，并配套一套统一的应用管理和启动机制，诸如微前端框架 Single-SPA 或者 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p> <p><strong>微件化</strong>，即通过对构建系统的 hack，使不同的前端应用可以使用同一套依赖。它在<strong>应用微服务化</strong>的基本上，改进了重复加载依赖文件的问题。</p> <p><strong>微应用化</strong>，又可以称之为<strong>组合式集成</strong>，即通过软件工程的方式，在开发环境对单体应用进行拆分，在构建环境将应用组合在一起构建成一个应用。详细的细节，可以期待后面的文章《一个单体前端应用的拆解与微服务化》</p> <h2 id="微前端方案的对比-复杂方式-2"><a href="#微前端方案的对比-复杂方式-2" class="header-anchor">#</a> 微前端方案的对比：复杂方式</h2> <p>之前看到一篇微服务相关的 <a href="https://www.softwarearchitekt.at/post/2017/12/28/a-software-architect-s-approach-towards-using-angular-and-spas-in-general-for-microservices-aka-microfrontends.aspx" target="_blank" rel="noopener noreferrer">文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，介绍了不同微服务的区别，其采用了一种比较有意思的对比方式特别详细，这里就使用同样的方式来展示：</p> <table><thead><tr><th>架构目标</th> <th>描述</th></tr></thead> <tbody><tr><td>a. 独立开发</td> <td>独立开发，而不受影响</td></tr> <tr><td>b. 独立部署</td> <td>能作为一个服务来单独部署</td></tr> <tr><td>c. 支持不同框架</td> <td>可以同时使用不同的框架，如 Angular、Vue、React</td></tr> <tr><td>d. 摇树优化</td> <td>能消除未使用的代码</td></tr> <tr><td>e. 环境隔离</td> <td>应用间的上下文不受干扰</td></tr> <tr><td>f. 多个应用同时运行</td> <td>不同应用可以同时运行</td></tr> <tr><td>g. 共用依赖</td> <td>不同应用是否共用底层依赖库</td></tr> <tr><td>h. 依赖冲突</td> <td>依赖的不同版本是否导致冲突</td></tr> <tr><td>i. 集成编译</td> <td>应用最后被编译成一个整体，而不是分开构建</td></tr></tbody></table> <p>那么，对于下表而言，表中的 a~j 分别表示上面的几种不同的架构考虑因素。</p> <p>（PS：考虑到  Web Components 几个单词的长度，暂时将它简称为 WC~~)</p> <table><thead><tr><th>方式</th> <th>a</th> <th>b</th> <th>c</th> <th>d</th> <th>e</th> <th>f</th> <th>g</th> <th>h</th> <th>i</th></tr></thead> <tbody><tr><td>路由分发</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td></td> <td></td> <td></td></tr> <tr><td>iFrame</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td></td> <td></td> <td></td></tr> <tr><td>应用微服务化</td> <td>O</td> <td>O</td> <td>O</td> <td></td> <td></td> <td>O</td> <td></td> <td></td> <td></td></tr> <tr><td>微件化</td> <td>O</td> <td>O</td> <td></td> <td></td> <td>-</td> <td>-</td> <td>O</td> <td>-</td> <td></td></tr> <tr><td>微应用化</td> <td>O</td> <td>O</td> <td></td> <td>O</td> <td>-</td> <td>-</td> <td>O</td> <td>-</td> <td>O</td></tr> <tr><td>纯 WC</td> <td>O</td> <td>O</td> <td></td> <td>O</td> <td>O</td> <td>O</td> <td>-</td> <td>-</td> <td>O</td></tr> <tr><td>结合 WC</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td></td> <td></td> <td>O</td></tr></tbody></table> <p>图中的 O 表示支持，空白表示不支持，- 表示不受影响。</p> <p>再结合之前的选型指南：</p> <p><img src="/assets/img/choice-your-microservices.8a002c9b.png" alt="微前端选型指南"></p> <p>（PS：本图采用 Keynote 绘制）</p> <p>你是否找到你想到的架构了？</p> <h1 id="如何解构单体前端应用-前端应用的微服务式拆分-2"><a href="#如何解构单体前端应用-前端应用的微服务式拆分-2" class="header-anchor">#</a> 如何解构单体前端应用——前端应用的微服务式拆分</h1> <blockquote><p>刷新页面？路由拆分？No，动态加载组件。</p></blockquote> <p>本文分为以下四部分：</p> <ul><li>前端微服务化思想介绍</li> <li>微前端的设计理念</li> <li>实战微前端架构设计</li> <li>基于 Mooa 进行前端微服务化</li></ul> <h2 id="前端微服化-2"><a href="#前端微服化-2" class="header-anchor">#</a> 前端微服化</h2> <p>对于前端微服化来说，有这么一些方案：</p> <ul><li>Web Component 显然可以一个很优秀的基础架构。然而，我们并不可能去大量地复写已有的应用。</li> <li>iFrame。你是说真的吗？</li> <li>另外一个微前端框架 Single-SPA，显然是一个更好的方式。然而，它并非 Production Ready。</li> <li>通过路由来切分应用，而这个跳转会影响用户体验。</li> <li>等等。</li></ul> <p>因此，当我们考虑前端微服务化的时候，我们希望：</p> <ul><li>独立部署</li> <li>独立开发</li> <li>技术无关</li> <li>不影响用户体验</li></ul> <h3 id="独立开发-2"><a href="#独立开发-2" class="header-anchor">#</a> 独立开发</h3> <p>在过去的几星期里，我花费了大量的时间在学习 Single-SPA 的代码。但是，我发现它在开发和部署上真的太麻烦了，完全达不到独立部署地标准。按 Single-SPA 的设计，我需要在入口文件中声名我的应用，然后才能去构建：</p> <div class="language- extra-class"><pre class="language-text"><code>declareChildApplication('inferno', () =&gt; import('src/inferno/inferno.app.js'), pathPrefix('/inferno'));
</code></pre></div><p>同时，在我的应用里，我还需要去指定我的生命周期。这就意味着，当我开发了一个新的应用时，必须更新两份代码：主工程和应用。这时我们还极可能在同一个源码里工作。</p> <p>当出现多个团队的时候，在同一份源码里工作，显然变得相当的不可靠——比如说，对方团队使用的是 Tab，而我们使用的是 2 个空格，隔壁的老王用的是 4 个空格。</p> <h3 id="独立部署-2"><a href="#独立部署-2" class="header-anchor">#</a> 独立部署</h3> <p>一个单体的前端应用最大的问题是，构建出来的 js、css 文件相当的巨大。而微前端则意味着，这个文件被独立地拆分成多个文件，它们便可以独立去部署应用。</p> <h3 id="我们真的需要技术无关吗-2"><a href="#我们真的需要技术无关吗-2" class="header-anchor">#</a> 我们真的需要技术无关吗？</h3> <p>等等，我们是否真的需要<strong>技术无关</strong>？如果我们不需要技术无关的话，微前端问题就很容易解决了。</p> <p>事实上，对于大部分的公司和团队来说，技术无关只是一个无关痛痒的话术。当一家公司的几个创始人使用了 Java，那么极有可能在未来的选型上继续使用 Java。除非，一些额外的服务来使用 Python 来实现人工智能。因此，在大部分的情况下，仍然是技术栈唯一。</p> <p>对于前端项目来说，更是如此：一个部门里基本上只会选用一个框架。</p> <p>于是，我们选择了 Angular。</p> <h3 id="不影响用户体验-2"><a href="#不影响用户体验-2" class="header-anchor">#</a> 不影响用户体验</h3> <p>使用路由跳转来进行前端微服务化，是一种很简单、高效的切分方式。然而，路由跳转地过程中，会有一个白屏的过程。在这个过程中，跳转前的应用和将要跳转的应用，都失去了对页面的控制权。如果这个应用出了问题，那么用户就会一脸懵逼。</p> <p>理想的情况下，它应该可以被控制。</p> <h2 id="微前端的设计理念-2"><a href="#微前端的设计理念-2" class="header-anchor">#</a> 微前端的设计理念</h2> <h3 id="设计理念一-中心化路由-2"><a href="#设计理念一-中心化路由-2" class="header-anchor">#</a> 设计理念一：中心化路由</h3> <p>互联网本质是去中心化的吗？不，DNS 决定了它不是。TAB，决定了它不是。</p> <p>微服务从本质上来说，它应该是去中心化的。但是，它又不能是完全的去中心化。对于一个微服务来说，它需要一个<strong>服务注册中心</strong>：</p> <blockquote><p>服务提供方要注册通告服务地址，服务的调用方要能发现目标服务。</p></blockquote> <p>对于一个前端应用来说，这个东西就是路由。</p> <p>从页面上来说，只有我们在网页上添加一个菜单链接，用户才能知道某个页面是可以使用的。</p> <p>而从代码上来说，那就是我们需要有一个地方来管理我们的应用：**发现存在哪些应用，哪个应用使用哪个路由。</p> <p><strong>管理好我们的路由，实际上就是管理好我们的应用</strong>。</p> <h3 id="设计理念二-标识化应用-2"><a href="#设计理念二-标识化应用-2" class="header-anchor">#</a> 设计理念二：标识化应用</h3> <p>在设计一个微前端框架的时候，为<strong>每个项目取一个名字的</strong>问题纠结了我很久——怎么去规范化这个东西。直到，我再一次想到了康威定律：</p> <blockquote><p>系统设计(产品结构等同组织形式，每个设计系统的组织，其产生的设计等同于组织之间的沟通结构。</p></blockquote> <p>换句人话说，就是同一个组织下，不可能有两个项目的名称是一样的。</p> <p>所以，这个问题很简单就解决了。</p> <h3 id="设计理念三-生命周期-2"><a href="#设计理念三-生命周期-2" class="header-anchor">#</a> 设计理念三：生命周期</h3> <p>Single-SPA 设计了一个基本的生命周期（虽然它没有统一管理），它包含了五种状态：</p> <ul><li>load，决定加载哪个应用，并绑定生命周期</li> <li>bootstrap，获取静态资源</li> <li>mount，安装应用，如创建 DOM 节点</li> <li>unload，删除应用的生命周期</li> <li>unmount，卸载应用，如删除 DOM 节点</li></ul> <p>于是，我在设计上基本上沿用了这个生命周期。显然，诸如 load 之类对于我的设计是多余的。</p> <h3 id="设计理念四-独立部署与配置自动化-2"><a href="#设计理念四-独立部署与配置自动化-2" class="header-anchor">#</a> 设计理念四：独立部署与配置自动化</h3> <p>从某种意义上来说，整个每系统是围绕着应用配置进行的。如果应用的配置能自动化，那么整个系统就自动化。</p> <p>当我们只开发一个新的组件，那么我们只需要更新我们的组件，并更新配置即可。而这个配置本身也应该是能自动生成的。</p> <h2 id="实战微前端架构设计-2"><a href="#实战微前端架构设计-2" class="header-anchor">#</a> 实战微前端架构设计</h2> <p>基于以上的前提，系统的工作流程如下所示：</p> <p><img src="/assets/img/mooa-graph.7272c84d.jpg" alt="系统工作流"></p> <p>整体的工程流程如下所示：</p> <ol><li>主工程在运行的时候，会去服务器获取最新的应用配置。</li> <li>主工程在获取到配置后，将一一创建应用，并为应用绑定生命周期。</li> <li>当主工程监测到路由变化的时候，将寻找是否有对应的路由匹配到应用。</li> <li>当匹配对对应应用时，则加载相应的应用。</li></ol> <p>故而，其对应的结构下图所示：</p> <p><img src="/assets/img/mooa-app.5053c432.jpg" alt="Architecture"></p> <p>整体的流程如下图所示：</p> <p><img src="/assets/img/workflow.83c7eccf.png" alt="Workflow"></p> <h3 id="独立部署与配置自动化-2"><a href="#独立部署与配置自动化-2" class="header-anchor">#</a> 独立部署与配置自动化</h3> <p>我们做的部署策略如下：我们的应用使用的配置文件叫 <code>apps.json</code>，由主工程去获取这个配置。每次部署的时候，我们只需要将 <code>apps.json</code> 指向最新的配置文件即可。配置的文件类如下所示：</p> <ol><li>96a7907e5488b6bb.json</li> <li>6ff3bfaaa2cd39ea.json</li> <li>dcd074685c97ab9b.json</li></ol> <p>一个应用的配置如下所示：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;help&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;selector&quot;</span><span class="token operator">:</span> <span class="token string">&quot;help-root&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;baseScriptUrl&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/assets/help&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;styles&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;styles.bundle.css&quot;</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">&quot;prefix&quot;</span><span class="token operator">:</span> <span class="token string">&quot;help&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;inline.bundle.js&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;polyfills.bundle.js&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;main.bundle.js&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的 <code>selector</code> 对应于应用所需要的 DOM 节点，prefix 则是用于 URL 路由上。这些都是自动从 <code>index.html</code> 文件和 <code>package.json</code> 中获取生成的。</p> <h3 id="应用间路由-事件-2"><a href="#应用间路由-事件-2" class="header-anchor">#</a> 应用间路由——事件</h3> <p>由于现在的应用变成了两部分：主工程和应用部分。就会出现一个问题：<strong>只有一个工程能捕获路由变化</strong>。当由主工程去改变应用的二级路由时，就无法有效地传达到子应用。在这时，只能通过事件的方式去通知子应用，子应用也需要监测是否是当前应用的路由。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>app<span class="token punctuation">.</span>name <span class="token operator">===</span> appName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> urlPrefix <span class="token operator">=</span> <span class="token string">'app'</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>urlPrefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    urlPrefix <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>window<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span>option<span class="token punctuation">.</span>urlPrefix<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span>
  router<span class="token punctuation">.</span><span class="token function">navigate</span><span class="token punctuation">(</span><span class="token punctuation">[</span>event<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>urlPrefix <span class="token operator">+</span> appName<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>相似的，当我们需要从应用 A 跳转到应用 B 时，我们也需要这样的一个机制：</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('mooa.routing.navigate', function(event: CustomEvent) {
  const opts = event.detail
  if (opts) {
    navigateAppByName(opts)
  }
})
</code></pre></div><p>剩下的诸如 Loading 动画也是类似的。</p> <h1 id="大型-angular-应用微前端的四种拆分策略-2"><a href="#大型-angular-应用微前端的四种拆分策略-2" class="header-anchor">#</a> 大型 Angular 应用微前端的四种拆分策略</h1> <p>上一个月，我们花了大量的时间不熂设计方案来拆分一个大型的 Angular 应用。从使用 Angular 的 Lazyload 到前端微服务化，进行了一系列的讨论。最后，我们终于有了结果，采用的是 Lazyload 变体：<strong>构建时集成代码</strong> 的方式。</p> <p>过去的几周里，作为一个 “专业” 的咨询师，一直忙于在为客户设计一个 Angular 拆分的服务化方案。主要是为了达成以下的设计目标：</p> <ul><li>构建插件化的 Web 开发平台，满足业务快速变化及分布式多团队并行开发的需求</li> <li>构建服务化的中间件，搭建高可用及高复用的前端微服务平台</li> <li>支持前端的独立交付及部署</li></ul> <p>简单地来说，就是要支持<strong>应用插件化开发</strong>，以及<strong>多团队并行开发</strong>。</p> <p><strong>应用插件化开发</strong>，其所要解决的主要问题是：臃肿的大型应用的拆分问题。大型前端应用，在开发的时候要面临大量的<strong>遗留代码</strong>、不同业务的代码耦合在一起，在线上的时候还要面临加载速度慢，运行效率低的问题。</p> <p>最后就落在了两个方案上：路由懒加载及其变体与前端微服务化</p> <h2 id="前端微服务化-路由懒加载及其变体-2"><a href="#前端微服务化-路由懒加载及其变体-2" class="header-anchor">#</a> 前端微服务化：路由懒加载及其变体</h2> <p>路由懒加载，即通过不同的路由来将应用切成不同的代码快，当路由被访问的时候，才加载对应组件。在诸如 Angular、Vue 框架里都可以通过路由 +  Webpack 打包的方式来实现。而，不可避免地就会需要一些问题：</p> <p><strong>难以多团队并行开发</strong>，路由拆分就意味着我们仍然是在一个源码库里工作的。也可以尝试拆分成不同的项目，再编译到一起。</p> <p><strong>每次发布需要重新编译</strong>，是的，当我们只是更新一个子模块的代码，我们要重新编译整个应用，再重新发布这个应用。而不能独立地去构建它，再发布它。</p> <p><strong>统一的 Vendor 版本</strong>，统一第三方依赖是一件好事。可问题的关键在于：每当我们添加一个新的依赖，我们可能就需要开会讨论一下。</p> <p>然而，标准 Route Lazyload 最大的问题就是<strong>难以多团队并行开发</strong>，这里之所以说的是 “难以” 是因为，还是有办法解决这个问题。在日常的开发中，一个小的团队会一直在一个代码库里开发，而一个大的团队则应该是在不同的代码库里开发。</p> <p>于是，我们在标准的路由懒加载之上做了一些尝试。</p> <p>对于一个二三十人规模的团队来说，他们可能在业务上归属于不同的部门，技术上也有一些不一致的规范，如 4 个空格、2 个空格还是使用 Tab 的问题。特别是当它是不同的公司和团队时，他们可能要放弃测试、代码静态检测、代码风格统一等等的一系列问题。</p> <h2 id="微服务化方案-子应用模式-2"><a href="#微服务化方案-子应用模式-2" class="header-anchor">#</a> 微服务化方案：子应用模式</h2> <p>除了路由懒加载，我们还可以采用子应用模式，即每个应用都是相互独立地。即我们有一个基座工程，当用户点击相应的路由时，我们去加载这个<strong>独立</strong> 的 Angular 应用；如果是同一个应用下的路由，就不需要重复加载了。而且，这些都可以依赖于浏览器缓存来做。</p> <p>除了路由懒加载，还可以采用的是类似于 Mooa 的应用嵌入方案。如下是基于 Mooa 框架 + Angular 开发而生成的 HTML 示例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;app-root _nghost-c0=&quot;&quot; ng-version=&quot;4.2.0&quot;&gt;
  ...
  &lt;app-home _nghost-c2=&quot;&quot;&gt;
    &lt;app-app1 _nghost-c0=&quot;&quot; ng-version=&quot;5.2.8&quot; style=&quot;display: none;&quot;&gt;&lt;nav _ngcontent-c0=&quot;&quot; class=&quot;navbar&quot;&gt;&lt;/app-app1&gt;
    &lt;iframe frameborder=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;http://localhost:4200/app/help/homeassets/iframe.html&quot; id=&quot;help_206547&quot;&gt;&lt;/iframe&gt;
  &lt;/app-home&gt;
&lt;/app-root&gt;
</code></pre></div><p>Mooa 提供了两种模式，一种是基于 Single-SPA 的实验做的，在同一页面加载、渲染两个 Angular 应用；一种是基于 iFrame 来提供独立的应用容器。</p> <p>解决了以下的问题：</p> <ul><li><strong>首页加载速度更快</strong>，因为只需要加载首页所需要的功能，而不是所有的依赖。</li> <li><strong>多个团队并行开发</strong>，每个团队里可以独立地在自己的项目里开发。</li> <li><strong>独立地进行模块化更新</strong>，现在我们只需要去单独更新我们的应用，而不需要更新整个完整的应用。</li></ul> <p>但是，它仍然包含有以下的问题：</p> <ul><li>重复加载依赖项，即我们在 A 应用中使用到的模块，在 B 应用中也会重新使用到。有一部分可以通过浏览器的缓存来自动解决。</li> <li>第一次打开对应的应用需要时间，当然<strong>预加载</strong>可以解决一部分问题。</li> <li>在非 iframe 模式下运行，会遇到难以预料的第三方依赖冲突。</li></ul> <p>于是在总结了一系列的讨论之后，我们形成了一系列的对比方案：</p> <h2 id="方案对比-2"><a href="#方案对比-2" class="header-anchor">#</a> 方案对比</h2> <p>在这个过程中，我们做了大量的方案设计与对比，便想写一篇文章对比一下之前的结果。先看一下图：</p> <p><img src="/assets/img/angular-split-code-compare.92481961.jpg" alt="Angular 代码拆分对比"></p> <p>表格对比：</p> <table><thead><tr><th>x</th> <th>标准 Lazyload</th> <th>构建时集成</th> <th>构建后集成</th> <th>应用独立</th></tr></thead> <tbody><tr><td>开发流程</td> <td>多个团队在同一个代码库里开发</td> <td>多个团队在不同的代码库里开发</td> <td>多个团队在不同的代码库里开发</td> <td>多个团队在不同的代码库里开发</td></tr> <tr><td>构建与发布</td> <td>构建时只需要拿这一份代码去构建、部署</td> <td>将不同代码库的代码整合到一起，再构建应用</td> <td>将直接编译成各个项目模块，运行时通过懒加载合并</td> <td>将直接编译成不同的几个应用，运行时通过主工程加载</td></tr> <tr><td>适用场景</td> <td>单一团队，依赖库少、业务单一</td> <td>多团队，依赖库少、业务单一</td> <td>多团队，依赖库少、业务单一</td> <td>多团队，依赖库多、业务复杂</td></tr> <tr><td>表现方式</td> <td>开发、构建、运行一体</td> <td>开发分离，构建时集成，运行一体</td> <td>开发分离，构建分离，运行一体</td> <td>开发、构建、运行分离</td></tr></tbody></table> <p>详细的介绍如下：</p> <h3 id="标准-lazyload-2"><a href="#标准-lazyload-2" class="header-anchor">#</a> 标准 LazyLoad</h3> <p>开发流程：多个团队在同一个代码库里开发，构建时只需要拿这一份代码去部署。</p> <p>行为：开发、构建、运行一体</p> <p>适用场景：单一团队，依赖库少、业务单一</p> <h3 id="lazyload-变体-1-构建时集成-2"><a href="#lazyload-变体-1-构建时集成-2" class="header-anchor">#</a> LazyLoad 变体 1：构建时集成</h3> <p>开发流程：多个团队在不同的代码库里开发，在构建时将不同代码库的代码整合到一起，再去构建这个应用。</p> <p>适用场景：多团队，依赖库少、业务单一</p> <p>变体-构建时集成：开发分离，构建时集成，运行一体</p> <h3 id="lazyload-变体-2-构建后集成-2"><a href="#lazyload-变体-2-构建后集成-2" class="header-anchor">#</a> LazyLoad 变体 2：构建后集成</h3> <p>开发流程：多个团队在不同的代码库里开发，在构建时将编译成不同的几份代码，运行时会通过懒加载合并到一起。</p> <p>适用场景：多团队，依赖库少、业务单一</p> <p>变体-构建后集成：开发分离，构建分离，运行一体</p> <h3 id="前端微服务化-2"><a href="#前端微服务化-2" class="header-anchor">#</a> 前端微服务化</h3> <p>开发流程：多个团队在不同的代码库里开发，在构建时将编译成不同的几个应用，运行时通过主工程加载。</p> <p>适用场景：多团队，依赖库多、业务复杂</p> <p>前端微服务化：开发、构建、运行分离</p> <h2 id="总对比-2"><a href="#总对比-2" class="header-anchor">#</a> 总对比</h2> <p>总体的对比如下表所示：</p> <table><thead><tr><th>x</th> <th>标准 Lazyload</th> <th>构建时集成</th> <th>构建后集成</th> <th>应用独立</th></tr></thead> <tbody><tr><td>依赖管理</td> <td>统一管理</td> <td>统一管理</td> <td>统一管理</td> <td>各应用独立管理</td></tr> <tr><td>部署方式</td> <td>统一部署</td> <td>统一部署</td> <td>可单独部署。更新依赖时，需要全量部署</td> <td>可完全独立部署</td></tr> <tr><td>首屏加载</td> <td>依赖在同一个文件，加载速度慢</td> <td>依赖在同一个文件，加载速度慢</td> <td>依赖在同一个文件，加载速度慢</td> <td>依赖各自管理，首页加载快</td></tr> <tr><td>首次加载应用、模块</td> <td>只加载模块，速度快</td> <td>只加载模块，速度快</td> <td>只加载模块，速度快</td> <td>单独加载，加载略慢</td></tr> <tr><td>前期构建成本</td> <td>低</td> <td>设计构建流程</td> <td>设计构建流程</td> <td>设计通讯机制与加载方式</td></tr> <tr><td>维护成本</td> <td>一个代码库不好管理</td> <td>多个代码库不好统一</td> <td>后期需要维护组件依赖</td> <td>后期维护成本低</td></tr> <tr><td>打包优化</td> <td>可进行摇树优化、AoT 编译、删除无用代码</td> <td>可进行摇树优化、AoT 编译、删除无用代码</td> <td>应用依赖的组件无法确定，不能删除无用代码</td> <td>可进行摇树优化、AoT 编译、删除无用代码</td></tr></tbody></table> <h1 id="前端微服务化-使用微前端框架-mooa-开发微前端应用-2"><a href="#前端微服务化-使用微前端框架-mooa-开发微前端应用-2" class="header-anchor">#</a> 前端微服务化：使用微前端框架 Mooa 开发微前端应用</h1> <p>Mooa 是一个为 Angular 服务的微前端框架，它是一个基于 <a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noopener noreferrer">single-spa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，针对 IE 10 及 IFRAME 优化的微前端解决方案。</p> <h2 id="mooa-概念-2"><a href="#mooa-概念-2" class="header-anchor">#</a> Mooa 概念</h2> <p>Mooa 框架与 Single-SPA 不一样的是，Mooa 采用的是 Master-Slave 架构，即主-从式设计。</p> <p>对于 Web 页面来说，它可以同时存在两个到多个的 Angular 应用：其中的一个 Angular 应用作为主工程存在，剩下的则是子应用模块。</p> <ul><li>主工程，负责加载其它应用，及用户权限管理等核心控制功能。</li> <li>子应用，负责不同模块的具体业务代码。</li></ul> <p>在这种模式下，则由主工程来控制整个系统的行为，子应用则做出一些对应的响应。</p> <h2 id="微前端主工程创建-2"><a href="#微前端主工程创建-2" class="header-anchor">#</a> 微前端主工程创建</h2> <p>要创建微前端框架 Mooa 的主工程，并不需要多少修改，只需要使用 <code>angular-cli</code> 来生成相应的应用：</p> <div class="language- extra-class"><pre class="language-text"><code>ng new hello-world
</code></pre></div><p>然后添加 <code>mooa</code> 依赖</p> <div class="language- extra-class"><pre class="language-text"><code>yarn add mooa
</code></pre></div><p>接着创建一个简单的配置文件 <code>apps.json</code>，放在 <code>assets</code> 目录下：</p> <div class="language- extra-class"><pre class="language-text"><code>[{
    &quot;name&quot;: &quot;help&quot;,
    &quot;selector&quot;: &quot;app-help&quot;,
    &quot;baseScriptUrl&quot;: &quot;/assets/help&quot;,
    &quot;styles&quot;: [
      &quot;styles.bundle.css&quot;
    ],
    &quot;prefix&quot;: &quot;help&quot;,
    &quot;scripts&quot;: [
      &quot;inline.bundle.js&quot;,
      &quot;polyfills.bundle.js&quot;,
      &quot;main.bundle.js&quot;
    ]
  }
]]
</code></pre></div><p>接着，在我们的 <code>app.component.ts</code> 中编写相应的创建应用逻辑：</p> <div class="language- extra-class"><pre class="language-text"><code>mooa = new Mooa({
  mode: 'iframe',
  debug: false,
  parentElement: 'app-home',
  urlPrefix: 'app',
  switchMode: 'coexist',
  preload: true,
  includeZone: true
});

constructor(private renderer: Renderer2, http: HttpClient, private router: Router) {
  http.get&lt;IAppOption[]&gt;('/assets/apps.json')
    .subscribe(
      data =&gt; {
        this.createApps(data);
      },
      err =&gt; console.log(err)
    );
}

private createApps(data: IAppOption[]) {
  data.map((config) =&gt; {
    this.mooa.registerApplication(config.name, config, mooaRouter.hashPrefix(config.prefix));
  });

  const that = this;
  this.router.events.subscribe((event) =&gt; {
    if (event instanceof NavigationEnd) {
      that.mooa.reRouter(event);
    }
  });

  return mooa.start();
}
</code></pre></div><p>再为应用创建一个对应的路由即可：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  path: 'app/:appName/:route',
  component: HomeComponent
}
</code></pre></div><p>接着，我们就可以创建 Mooa 子应用。</p> <h2 id="mooa-子应用创建-2"><a href="#mooa-子应用创建-2" class="header-anchor">#</a> Mooa 子应用创建</h2> <p>Mooa 官方提供了一个子应用的模块，直接使用该模块即可：</p> <div class="language- extra-class"><pre class="language-text"><code>git clone https://github.com/phodal/mooa-boilerplate
</code></pre></div><p>然后执行：</p> <div class="language- extra-class"><pre class="language-text"><code>npm install
</code></pre></div><p>在安装完依赖后，会进行项目的初始化设置，如更改包名等操作。在这里，将我们的应用取名为 help。</p> <p>然后，我们就可以完成子应用的构建。</p> <p>接着，执行：<code>yarn build</code> 就可以构建出我们的应用。</p> <p>将 <code>dist</code> 目录一下的文件拷贝到主工程的 src/assets/help 目录下，再启动主工程即可。</p> <h2 id="导航到特定的子应用-2"><a href="#导航到特定的子应用-2" class="header-anchor">#</a> 导航到特定的子应用</h2> <p>在 Mooa 中，有一个路由接口 <code>mooaPlatform.navigateTo</code>，具体使用情况如下：</p> <div class="language- extra-class"><pre class="language-text"><code>mooaPlatform.navigateTo({
  appName: 'help',
  router: 'home'
});
</code></pre></div><p>它将触发一个 <code>MOOA_EVENT.ROUTING_NAVIGATE</code> 事件。而在我们调用 <code>mooa.start()</code> 方法时，则会开发监听对应的事件：</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener(MOOA_EVENT.ROUTING_NAVIGATE, function(event: CustomEvent) {
  if (event.detail) {
    navigateAppByName(event.detail)
  }
})
</code></pre></div><p>它将负责将应用导向新的应用。</p> <p>嗯，就是这么简单。DEMO 视频如下：</p> <p>Demo 地址见：<a href="http://mooa.phodal.com/" target="_blank" rel="noopener noreferrer">http://mooa.phodal.com/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>GitHub 示例：<a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">https://github.com/phodal/mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="前端微服务化-使用特制的-iframe-微服务化-angular-应用-2"><a href="#前端微服务化-使用特制的-iframe-微服务化-angular-应用-2" class="header-anchor">#</a> 前端微服务化：使用特制的 iframe 微服务化 Angular 应用</h1> <p>Angular 基于 Component 的思想，可以让其在一个页面上同时运行多个 Angular 应用；可以在一个 DOM 节点下，存在多个 Angular 应用，即类似于下面的形式：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-home</span> <span class="token attr-name">_nghost-c3</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-help</span> <span class="token attr-name">_nghost-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.2<span class="token punctuation">&quot;</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">_ngcontent-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-help</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-app1</span> <span class="token attr-name">_nghost-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.3<span class="token punctuation">&quot;</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">_ngcontent-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>navbar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-app1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-app2</span> <span class="token attr-name">_nghost-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.2<span class="token punctuation">&quot;</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">_ngcontent-c0</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>navbar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-app2</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-home</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>可这一样一来，难免需要做以下的一些额外的工作：</p> <ul><li>创建子应用项目模板，以统一 Angular 版本</li> <li>构建时，删除子应用的依赖</li> <li>修改第三方模块</li></ul> <p>而在这其中最麻烦的就是<strong>第三方模块</strong>冲突问题。思来想去，在三月中旬，我在 Mooa 中添加了一个 iframe 模式。</p> <h2 id="iframe-微服务架构设计-2"><a href="#iframe-微服务架构设计-2" class="header-anchor">#</a> iframe 微服务架构设计</h2> <p>在这里，总的设计思想和之前的《<a href="https://www.phodal.com/blog/how-to-build-a-microfrontend-framework-mooa/" target="_blank" rel="noopener noreferrer">如何解构单体前端应用——前端应用的微服务式拆分<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》中介绍是一致的：</p> <p><img src="/assets/img/mooa-graph.7272c84d.jpg" alt="Mooa 架构"></p> <p>主要过程如下：</p> <ul><li>主工程在运行的时候，会去服务器获取最新的应用配置。</li> <li>主工程在获取到配置后，将一一创建应用，并为应用绑定生命周期。</li> <li>当主工程监测到路由变化的时候，将寻找是否有对应的路由匹配到应用。</li> <li>当匹配对对应应用时，则<strong>创建或显示相应应用的 iframe</strong>，并隐藏其它子应用的 iframe。</li></ul> <p>其加载形式与之前的 Component 模式并没有太大的区别：</p> <p><img src="/assets/img/mooa-app.5053c432.jpg" alt="Mooa Component 加载"></p> <p>而为了控制不同的 iframe 需要做到这么几件事：</p> <ol><li>为不同的子应用分配 ID</li> <li>在子应用中进行 hook，以通知主应用：子应用已加载</li> <li>在子应用中创建对应的事件监听，来响应主应用的 URL 变化事件</li> <li>在主应用中监听子程序的路由跳转等需求</li></ol> <p>因为大部分的代码可以与之前的 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">Mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 复用，于是我便在 Mooa 中实现了相应的功能。</p> <h2 id="微前端框架-mooa-的特制-iframe-模式-2"><a href="#微前端框架-mooa-的特制-iframe-模式-2" class="header-anchor">#</a> 微前端框架 Mooa 的特制 iframe 模式</h2> <p>iframe 可以创建一个<strong>全新的独立的宿主环境</strong>，这意味着我们的 Angular 应用之间可以相互独立运行，我们唯一要做的是：<strong>建立一个通讯机制</strong>。</p> <p>它可以不修改子应用代码的情况下，可以直接使用。与此同时，它在一般的 iframe 模式进行了优化。使用普通的 iframe 模式，意味着：<strong>我们需要加载大量的重复组件</strong>，即使经过 Tree-Shaking 优化，它也将带来大量的重复内容。如果子应用过多，那么它在初始化应用的时候，体验可能就没有那么友好。但是与此相比，在初始化应用的时候，加载所有的依赖在主程序上，也不是一种很友好的体验。</p> <p>于是，我就在想能不能创建一个更友好地 IFrame 模式，在里面对应用及依赖进行处理。如下，就是最后生成的页面的 iframe 代码：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-home</span> <span class="token attr-name">_nghost-c2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">ng-version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5.2.8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100%<span class="token punctuation">&quot;</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100%<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://localhost:4200/assets/iframe.html<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>help_206547<span class="token punctuation">&quot;</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100%<span class="token punctuation">&quot;</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100%<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://localhost:4200/assets/iframe.html<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id=&quot;app_235458</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-home</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>对，两个 iframe 的 src 是一样的，但是它表现出来的确实是两个不同的 iframe 应用。那个 iframe.html 里面其实是没有内容的：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token name">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>App1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width,initial-scale=1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>icon<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image/x-icon<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>favicon.ico<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>（PS：详细的代码可以见 <a href="https://github.com/phodal/mooa" target="_blank" rel="noopener noreferrer">https://github.com/phodal/mooa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</p> <p>只是为了创建 iframe 的需要而存在的，对于一个 Angular 应用来说，是不是一个 iframe 的区别并不大。但是，对于我们而言，区别就大了。我们可以使用自己的方式来控制这个 IFrame，以及我们所要加载的内容。如：</p> <ul><li>共同 Style Guide 中的 CSS 样式。如，在使用 iframe 集成时，移除不需要的 <link></li> <li>去除不需要重复加载的 JavaScript。如，打包时不需要的 zone.min.js、polyfill.js 等等</li></ul> <p><code>注意</code>：对于一些共用 UI 组件而言，仍然需要重复加载。这也就是 iframe 模式下的问题。</p> <h2 id="微前端框架-mooa-iframe-通讯机制-2"><a href="#微前端框架-mooa-iframe-通讯机制-2" class="header-anchor">#</a> 微前端框架 Mooa iframe 通讯机制</h2> <p>为了在主工程与子工程通讯，我们需要做到这么一些事件策略：</p> <h3 id="发布主应用事件-2"><a href="#发布主应用事件-2" class="header-anchor">#</a> 发布主应用事件</h3> <p>由于，我们使用 Mooa 来控制 iframe 加载。这就意味着我们可以通过 <code>document.getElementById</code> 来获取到 iframe，随后通过 <code>iframeEl.contentWindow</code> 来发布事件，如下：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> iframeEl<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>iframeId<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>iframeEl <span class="token operator">&amp;&amp;</span> iframeEl<span class="token punctuation">.</span>contentWindow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  iframeEl<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span>option <span class="token operator">=</span> window<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span>option
  iframeEl<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span><span class="token constant">MOOA_EVENT</span><span class="token punctuation">.</span><span class="token constant">ROUTING_CHANGE</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> detail<span class="token operator">:</span> eventArgs <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样，子应用就不需要修改代码，就可以直接接收对应的事件响应。</p> <h3 id="监听子应用事件-2"><a href="#监听子应用事件-2" class="header-anchor">#</a> 监听子应用事件</h3> <p>由于，我们也希望能直接在主工程中处理子程序的事件，并且不修改原有的代码。因此，我们也使用同样的方式来在子应用中监听主应用的事件：</p> <div class="language- extra-class"><pre class="language-text"><code>iframeEl.contentWindow.addEventListener(MOOA_EVENT.ROUTING_NAVIGATE, function(event: CustomEvent) {
  if (event.detail) {
    navigateAppByName(event.detail)
  }
})
</code></pre></div><h2 id="示例-2"><a href="#示例-2" class="header-anchor">#</a> 示例</h2> <p>同样的我们仍以 Mooa 框架作为示例，我们只需要在创建 mooa 实例时，配置使用 iframe 模式即可：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>mooa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mooa</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'iframe'</span><span class="token punctuation">,</span>
  debug<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  parentElement<span class="token operator">:</span> <span class="token string">'app-home'</span><span class="token punctuation">,</span>
  urlPrefix<span class="token operator">:</span> <span class="token string">'app'</span><span class="token punctuation">,</span>
  switchMode<span class="token operator">:</span> <span class="token string">'coexist'</span><span class="token punctuation">,</span>
  preload<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  includeZone<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">...</span>

that<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span><span class="token function">registerApplicationByLink</span><span class="token punctuation">(</span><span class="token string">'help'</span><span class="token punctuation">,</span> <span class="token string">'/assets/help'</span><span class="token punctuation">,</span> mooaRouter<span class="token punctuation">.</span><span class="token function">matchRoute</span><span class="token punctuation">(</span><span class="token string">'help'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
that<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span><span class="token function">registerApplicationByLink</span><span class="token punctuation">(</span><span class="token string">'app1'</span><span class="token punctuation">,</span> <span class="token string">'/assets/app1'</span><span class="token punctuation">,</span> mooaRouter<span class="token punctuation">.</span><span class="token function">matchRoute</span><span class="token punctuation">(</span><span class="token string">'app1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>mooa<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">...</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>router<span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token keyword">instanceof</span> <span class="token class-name">NavigationEnd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    that<span class="token punctuation">.</span>mooa<span class="token punctuation">.</span><span class="token function">reRouter</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>子程序则直接使用：<a href="https://github.com/phodal/mooa-boilerplate" target="_blank" rel="noopener noreferrer">https://github.com/phodal/mooa-boilerplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就可以了。</p> <h1 id="资源-2"><a href="#资源-2" class="header-anchor">#</a> 资源</h1> <p>相关资料：</p> <ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/%E5%BD%B1%E5%AD%90_DOM" target="_blank" rel="noopener noreferrer">MDN 影子DOM（Shadow DOM）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="noopener noreferrer">Web Components<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developers.google.com/web/fundamentals/web-components/shadowdom?hl=zh-cn" target="_blank" rel="noopener noreferrer">Shadow DOM v1：独立的网络组件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/phodal/microfrontends" target="_blank" rel="noopener noreferrer">github<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener noreferrer">qiankun<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/aliyun/alibabacloud-alfa" target="_blank" rel="noopener noreferrer">alibabacloud-alfa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6948752328715403300" target="_blank" rel="noopener noreferrer">worker 沙箱猜想<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/ampproject/worker-dom" target="_blank" rel="noopener noreferrer">worker DOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6862661545592111111" target="_blank" rel="noopener noreferrer">qiankun1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6885211340999229454" target="_blank" rel="noopener noreferrer">qiankun2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6885214342552223757" target="_blank" rel="noopener noreferrer">qiankun3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6885212507837825038" target="_blank" rel="noopener noreferrer">qiankun4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/25/2021, 12:07:28 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.04e7effe.js" defer></script><script src="/assets/js/2.7500209f.js" defer></script><script src="/assets/js/4.31e593be.js" defer></script>
  </body>
</html>
